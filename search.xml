<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Git强制拉取与推送</title>
      <link href="/xyzhangblog/2020/10/18/git/git-qiang-zhi-la-qu-yu-tui-song/git-qiang-zhi-la-qu-yu-tui-song/"/>
      <url>/xyzhangblog/2020/10/18/git/git-qiang-zhi-la-qu-yu-tui-song/git-qiang-zhi-la-qu-yu-tui-song/</url>
      
        <content type="html"><![CDATA[<h2 id="Git强制拉取"><a href="#Git强制拉取" class="headerlink" title="Git强制拉取"></a>Git强制拉取</h2><p>有时本地修改代码出现异常，需要将本地修改全部忽略，强制拉取远端</p><pre class=" language-bash"><code class="language-bash">// 方法1: 清空本地修改后 拉取远端代码<span class="token function">git</span> reset --hard<span class="token function">git</span> pull// 方法2: 直接拉取远端代码将HEAD指向master最新版本<span class="token function">git</span> fetch --all<span class="token function">git</span> reset --hard origin/master<span class="token function">git</span> pull</code></pre><h2 id="Git强制推送"><a href="#Git强制推送" class="headerlink" title="Git强制推送"></a>Git强制推送</h2><p>强制用本地代码覆盖远程仓库</p><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> push -f origin master</code></pre><p>TODO: 解决git冲突</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ProtoBuf使用总结</title>
      <link href="/xyzhangblog/2020/10/17/bian-cheng-xiang-guan-ji-zhu/protobuf-shi-yong/protobuf-shi-yong/"/>
      <url>/xyzhangblog/2020/10/17/bian-cheng-xiang-guan-ji-zhu/protobuf-shi-yong/protobuf-shi-yong/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-序列化"><a href="#0x00-序列化" class="headerlink" title="0x00 序列化"></a>0x00 序列化</h2><p><strong>序列化是指将数据结构或者对象的状态转换成可存储（文件/内存）、可传输的格式</strong> 反之从存储或传输形式转换为数据结构或对象的形式成为反序列化</p><p>常见的序列化格式有：XML、JSON、YAML、plist…</p><h2 id="0x01-Protocol-Buffers简介"><a href="#0x01-Protocol-Buffers简介" class="headerlink" title="0x01 Protocol Buffers简介"></a>0x01 Protocol Buffers简介</h2><blockquote><p>ProtoBuf：google推出的语言中立，平台无关，可扩展的序列化数据的格式，可用于通信协议，数据存储等；相比XML更小巧、快速、简单。一旦定义要处理的数据的数据结构后，就可以利用ProtoBuf的代码生成工具生成相关代码。只需使用Protobuf对数据结构进行一次描述，就可以利用不同语言或从不同数据流中对结构化数据进行读写。</p></blockquote><p>Protocol buffers适合做数据存储或RPC数据交换格式。可用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化结构数据格式。Protocol buffers包含序列化格式的定义、对应语言的库和IDL编译器，正常情况下需要定义proto文件，然后使用IDL编译器编译成需要的语言。</p><p><strong>protocol buffers 诞生之初是为了解决服务器端新旧协议(高低版本)兼容性问题，名字也很体贴，“协议缓冲区”。只不过后期慢慢发展成用于传输数据</strong>。</p><h2 id="0x02-Protocol-Buffers的特点及用法"><a href="#0x02-Protocol-Buffers的特点及用法" class="headerlink" title="0x02 Protocol Buffers的特点及用法"></a>0x02 Protocol Buffers的特点及用法</h2><h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><ul><li>便捷引入新字段，且无需了解所有字段服务器即可进行数据的解析和传递</li><li>数据格式更具自我描述性</li><li>序列化与反序列化代码可以自动生成，避免手动解析</li></ul><h3 id="用法："><a href="#用法：" class="headerlink" title="用法："></a>用法：</h3><p>proto中所有结构化数据都被称为<code>message</code></p><pre class=" language-proto"><code class="language-proto">syntax = "proto3";message SearchRequest {  string query = 1;  int32 page_number = 2;  int32 result_per_page = 3;}</code></pre><h3 id="1-分配字段编号"><a href="#1-分配字段编号" class="headerlink" title="1. 分配字段编号"></a>1. 分配字段编号</h3><p>每个消息定义中的每个字段都有<strong>唯一的编号</strong>。这些字段编号用于标识消息二进制格式中的字段，并且在使用消息类型后不应更改。请注意，范围 1 到 15 中的字段编号需要一个字节进行编码，包括字段编号和字段类型。范围 16 至 2047 中的字段编号需要两个字节。所以你应该保留数字 1 到 15 作为非常频繁出现的消息元素。请记住为将来可能添加的频繁出现的元素留出一些空间。</p><p>可以指定的最小字段编号为1，最大字段编号为2^29^-1 或 536,870,911。也不能使用数字 19000 到 19999（FieldDescriptor :: kFirstReservedNumber 到 FieldDescriptor :: kLastReservedNumber），因为它们是为 Protocol Buffers实现保留的。</p><p>如果在 .proto 中使用这些保留数字中的一个，Protocol Buffers 编译的时候会报错。</p><p>同样，您不能使用任何以前 Protocol Buffers 保留的一些字段号码。保留字段是什么，下一节详细说明。</p><h3 id="2-保留字段"><a href="#2-保留字段" class="headerlink" title="2. 保留字段"></a>2. 保留字段</h3><p>如果您通过完全删除某个字段或将其注释掉来更新消息类型，那么未来的用户可以在对该类型进行自己的更新时重新使用该字段号。如果稍后加载到了的旧版本 <code>.proto</code> 文件，则会导致服务器出现严重问题，例如数据混乱，隐私错误等等。确保这种情况不会发生的一种方法是指定删除字段的字段编号（或名称，这也可能会导致 JSON 序列化问题）为 <code>reserved</code>。如果将来的任何用户试图使用这些字段标识符，Protocol Buffers 编译器将会报错。</p><pre class=" language-proto"><code class="language-proto">message Foo {  reserved 2, 15, 9 to 11;  reserved "foo", "bar";}</code></pre><p><strong>注意，不能在同一个 <code>reserved</code> 语句中混合字段名称和字段编号</strong>。如有需要需要像上面这个例子这样写。</p><h3 id="3-默认字段规则"><a href="#3-默认字段规则" class="headerlink" title="3. 默认字段规则"></a>3. 默认字段规则</h3><ul><li>字段名不能重复，必须唯一。</li><li>repeated 字段：可以在一个 message 中重复任何数字多次(包括 0 )，不过这些重复值的顺序被保留。</li></ul><h2 id="0x03-Protocol-Buffers的优缺点"><a href="#0x03-Protocol-Buffers的优缺点" class="headerlink" title="0x03 Protocol Buffers的优缺点"></a>0x03 Protocol Buffers的优缺点</h2><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ul><li>简单</li><li>数据体积小</li><li>反序列化速度快</li><li>自动化生成易于编码方式使用的数据访问类</li></ul><h4 id="举个例子："><a href="#举个例子：" class="headerlink" title="举个例子："></a>举个例子：</h4><p>如果要编码一个用户的名字和 email 信息，用 XML 的方式如下：</p><pre class=" language-xml"><code class="language-xml">  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>person</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>John Doe<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>email</span><span class="token punctuation">></span></span>jdoe@example.com<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>email</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>person</span><span class="token punctuation">></span></span></code></pre><p>相同需求，如果换成 protocol buffers 来实现，定义文件如下：</p><pre class=" language-c"><code class="language-c"><span class="token macro property"># Textual representation of a protocol buffer.</span><span class="token macro property"># This is *not* the binary format used on the wire.</span>person <span class="token punctuation">{</span>  name<span class="token punctuation">:</span> <span class="token string">"John Doe"</span>  email<span class="token punctuation">:</span> <span class="token string">"jdoe@example.com"</span><span class="token punctuation">}</span></code></pre><p>protocol buffers 通过编码以后，以二进制的方式进行数据传输，最多只需要 28 bytes 空间和 100-200 ns 的反序列化时间。但是 XML 则至少需要 69 bytes 空间（经过压缩以后，去掉所有空格）和 5000-10000 的反序列化时间。</p><p>上面说的是性能方面的优势。接下来说说编码方面的优势。</p><p>protocol buffers 自带代码生成工具，可以生成友好的数据访问存储接口。从而开发人员使用它来编码更加方便。例如上面的例子，如果用 C++ 的方式去读取用户的名字和 email，直接调用对应的 get 方法即可（所有属性的 get 和 set 方法的代码都自动生成好了，只需要调用即可）</p><pre class=" language-c"><code class="language-c">  cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Name: "</span> <span class="token operator">&lt;&lt;</span> person<span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>  cout <span class="token operator">&lt;&lt;</span> <span class="token string">"E-mail: "</span> <span class="token operator">&lt;&lt;</span> person<span class="token punctuation">.</span><span class="token function">email</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></code></pre><p>而 XML 读取数据会麻烦一些：</p><pre class=" language-xml"><code class="language-xml">  cout &lt;&lt; "Name: "       &lt;&lt; person.getElementsByTagName("name")->item(0)->innerText()       &lt;&lt; endl;  cout &lt;&lt; "E-mail: "       &lt;&lt; person.getElementsByTagName("email")->item(0)->innerText()       &lt;&lt; endl;</code></pre><p>Protobuf 语义更清晰，无需类似 XML 解析器的东西（因为 Protobuf 编译器会将 .proto 文件编译生成对应的数据访问类以对 Protobuf 数据进行序列化、反序列化操作）。</p><p>使用 Protobuf 无需学习复杂的文档对象模型，Protobuf 的编程模式比较友好，简单易学，同时它拥有良好的文档和示例，对于喜欢简单事物的人们而言，Protobuf 比其他的技术更加有吸引力。</p><p>protocol buffers 最后一个非常棒的特性是，即“向后”兼容性好，人们不必破坏已部署的、依靠“老”数据格式的程序就可以对数据结构进行升级。这样您的程序就可以不必担心因为消息结构的改变而造成的大规模的代码重构或者迁移的问题。因为添加新的消息中的 field 并不会引起已经发布的程序的任何改变(因为存储方式本来就是无序的，k-v 形式)。</p><p>当然 protocol buffers 也并不是完美的，在使用上存在一些局限性。</p><p>由于文本并不适合用来描述数据结构，所以 Protobuf 也不适合用来对基于文本的标记文档（如 HTML）建模。另外，由于 XML 具有某种程度上的自解释性，它可以被人直接读取编辑，在这一点上 Protobuf 不行，它以二进制的方式存储，除非你有 <code>.proto</code> 定义，否则你没法直接读出 Protobuf 的任何内容。</p><h2 id="0x04-参考资料："><a href="#0x04-参考资料：" class="headerlink" title="0x04 参考资料："></a>0x04 参考资料：</h2><p>pb的编码原理、更详细的用法分析：<a href="https://halfrost.com/protobuf_encode/">https://halfrost.com/protobuf_encode/</a></p><p>pb的性能分析参考：<a href="https://halfrost.com/protobuf_decode/#toc-13">https://halfrost.com/protobuf_decode/#toc-13</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> ProtoBuf </tag>
            
            <tag> 序列化 </tag>
            
            <tag> 反序列化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32+TencentOSTiny实现甲醛传感器</title>
      <link href="/xyzhangblog/2020/10/01/iot/tencentostiny-jia-quan-chuan-gan-qi/tencentostiny-ti-yan/"/>
      <url>/xyzhangblog/2020/10/01/iot/tencentostiny-jia-quan-chuan-gan-qi/tencentostiny-ti-yan/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-环境说明"><a href="#0x00-环境说明" class="headerlink" title="0x00. 环境说明"></a>0x00. 环境说明</h2><ul><li>软件环境：win10 64位 + MDK</li><li>开发板：TOS_EVB_G0开发板 x 1</li><li>传感器：英国 Dart 甲醛传感器 x 1</li><li>扩展板：E53甲醛传感器底板 x 1</li><li>下载器：ST-Link下载器 x 1</li></ul><h2 id="0x01-安装基础工具（硬件）"><a href="#0x01-安装基础工具（硬件）" class="headerlink" title="0x01. 安装基础工具（硬件）"></a>0x01. 安装基础工具（硬件）</h2><h4 id="连接ST-Link与开发板，严格按照如下方式进行连接否则可能烧坏MCU"><a href="#连接ST-Link与开发板，严格按照如下方式进行连接否则可能烧坏MCU" class="headerlink" title="连接ST-Link与开发板，严格按照如下方式进行连接否则可能烧坏MCU"></a>连接ST-Link与开发板，严格按照如下方式进行连接否则可能烧坏MCU</h4><p>开发板3v3—&gt; STlink 3.3V<br>开发板DIO—&gt; STlink SWDIO<br>开发板CLK—&gt; STlink SWCLK<br>开发板GND—&gt; STlink GND</p><h4 id="设置跳线帽，切换boot选择端子和串口选择端子"><a href="#设置跳线帽，切换boot选择端子和串口选择端子" class="headerlink" title="设置跳线帽，切换boot选择端子和串口选择端子"></a>设置跳线帽，切换boot选择端子和串口选择端子</h4><ol><li>开发版上的ESP固件下载配置切换到GND，使wifi处于下载模式</li><li>Boot选择切换到0</li><li>串口切换端子置于中间，使ESP8266直接与PC串口连接</li></ol><p>设置完成后的结果如下图所示：</p><img src="/xyzhangblog/2020/10/01/iot/tencentostiny-jia-quan-chuan-gan-qi/tencentostiny-ti-yan/%E7%AB%AF%E5%AD%90%E8%AE%BE%E7%BD%AE.jpg" class="" title="端子设置"><h2 id="0x02-安装基础工具（软件）"><a href="#0x02-安装基础工具（软件）" class="headerlink" title="0x02. 安装基础工具（软件）"></a>0x02. 安装基础工具（软件）</h2><h4 id="安装MDK软件"><a href="#安装MDK软件" class="headerlink" title="安装MDK软件"></a>安装MDK软件</h4><ul><li><p>激活软件，导入License，注意这部需要以管理员身份运行</p></li><li><p>安装单片机型号中对应的Pack</p><p>可以直接在MDK软件上在线安装，在导航栏打开Pack安装页面，找到STM32G0xx，点击install安装</p><img src="/xyzhangblog/2020/10/01/iot/tencentostiny-jia-quan-chuan-gan-qi/tencentostiny-ti-yan/image-20201001164941942.png" class="" title="image-20201001164941942"></li></ul><h4 id="安装ST-Link驱动"><a href="#安装ST-Link驱动" class="headerlink" title="安装ST-Link驱动"></a>安装ST-Link驱动</h4><p>前往ST官网即可下载：</p><p><a href="https://www.st.com/content/st_com/zh/products/development-tools/software-development-tools/stm32-software-development-tools/stm32-utilities/stsw-link009.html">https://www.st.com/content/st_com/zh/products/development-tools/software-development-tools/stm32-software-development-tools/stm32-utilities/stsw-link009.html</a></p><p>安装完成后打开设备管理器，查看通用串行总线设备，出现如下所示，则驱动安装成功</p><img src="/xyzhangblog/2020/10/01/iot/tencentostiny-jia-quan-chuan-gan-qi/tencentostiny-ti-yan/image-20201001165811036.png" class="" title="image-20201001165811036"><h4 id="CH340串口驱动安装"><a href="#CH340串口驱动安装" class="headerlink" title="CH340串口驱动安装"></a>CH340串口驱动安装</h4><p>直接通过互联网搜索CH340串口芯片的驱动进行下载安装即可</p><img src="/xyzhangblog/2020/10/01/iot/tencentostiny-jia-quan-chuan-gan-qi/tencentostiny-ti-yan/image-20201001163019855.png" class="" title="image-20201001163019855"><h4 id="安装串口调试助手"><a href="#安装串口调试助手" class="headerlink" title="安装串口调试助手"></a>安装串口调试助手</h4><p>工具下载：<a href="http://www.daxia.com/download/sscom.rar">http://www.daxia.com/download/sscom.rar</a></p><img src="/xyzhangblog/2020/10/01/iot/tencentostiny-jia-quan-chuan-gan-qi/tencentostiny-ti-yan/image-20201001164049729.png" class="" title="image-20201001164049729"><p>根据PC和终端之间的连接选择正确的串行端口。</p><p>打开设备管理器，在端口列表（如果没有端口选项需要在“查看”中选取“显示隐藏的设备”）中可以看到连接所使用的端口号</p><p><del>这里遇到一个非常蠢的问题：STLink和USB需要同时连接到板子上，否则就会出现电脑不识别CH340设备的现象</del></p><img src="/xyzhangblog/2020/10/01/iot/tencentostiny-jia-quan-chuan-gan-qi/tencentostiny-ti-yan/image-20201001172758481.png" class="" title="image-20201001172758481"><h2 id="0x03-烧写腾讯云定制固件"><a href="#0x03-烧写腾讯云定制固件" class="headerlink" title="0x03. 烧写腾讯云定制固件"></a>0x03. 烧写腾讯云定制固件</h2><h4 id="下载固件"><a href="#下载固件" class="headerlink" title="下载固件"></a>下载固件</h4><p>下载链接：<a href="https://github.com/tencentyun/qcloud-iot-esp-wifi">https://github.com/tencentyun/qcloud-iot-esp-wifi</a> 、</p><p>使用git下载的命令如下：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> clone https://github.com/tencentyun/qcloud-iot-esp-wifi.git</code></pre><h4 id="下载烧写工具"><a href="#下载烧写工具" class="headerlink" title="下载烧写工具"></a>下载烧写工具</h4><p>前往乐鑫官网下载Flash下载工具：</p><p><a href="https://www.espressif.com/zh-hans/support/download/other-tools">https://www.espressif.com/zh-hans/support/download/other-tools</a></p><h4 id="固件说明"><a href="#固件说明" class="headerlink" title="固件说明"></a>固件说明</h4><p>腾讯云IoT定制的AT模组固件QCloud_IoT_AT_ESP8266，适用于所有FLASH大小为2MB或者2MB以上的 ESP8266模组。 </p><p>AT串口使用UART0，默认的Tx为GPIO1，Rx为GPIO3。但因为ESP8266的UART0 默认会在上电启动期 间输出一些打印，如果打印信息影响设备功能，可在上电期间将 U0TXD(GPIO1)、U0RXD(GPIO3) 分别 与 U0RTS (GPIO15)，U0CTS(GPIO13)进行交换，以屏蔽打印。因此提供两个版本的固件：</p><ul><li>名称包含UART_1_3的固件串口使用的Tx为GPIO1，Rx为GPIO3。 </li><li>名称包含UART_15_13的固件串口使用的Tx为GPIO15，Rx为GPIO13。 </li></ul><p>进入QCloud_IoT_AT_ESP8266_FW，本文中我们使用第一个固件</p><h4 id="烧写固件"><a href="#烧写固件" class="headerlink" title="烧写固件"></a>烧写固件</h4><h5 id="运行下载的乐鑫Flash烧写工具"><a href="#运行下载的乐鑫Flash烧写工具" class="headerlink" title="运行下载的乐鑫Flash烧写工具"></a>运行下载的乐鑫Flash烧写工具</h5><ol><li><p>选择Develop Mode</p></li><li><p>选择ESP8266下载工具</p><img src="/xyzhangblog/2020/10/01/iot/tencentostiny-jia-quan-chuan-gan-qi/tencentostiny-ti-yan/image-20201001175540012.png" class="" title="image-20201001175540012"><p>按照上图设置进行配置点击Start后等待下载完成</p></li><li><p>下载完成</p><img src="/xyzhangblog/2020/10/01/iot/tencentostiny-jia-quan-chuan-gan-qi/tencentostiny-ti-yan/image-20201001175803789.png" class="" title="image-20201001175803789"><p>完成后即可关闭工具，<strong>将串口选择端子恢复到默认状态</strong></p></li></ol><h2 id="0x04-接入腾讯云IoT"><a href="#0x04-接入腾讯云IoT" class="headerlink" title="0x04. 接入腾讯云IoT"></a>0x04. 接入腾讯云IoT</h2><h3 id="云端操作"><a href="#云端操作" class="headerlink" title="云端操作"></a>云端操作</h3><h4 id="新建项目及产品"><a href="#新建项目及产品" class="headerlink" title="新建项目及产品"></a>新建项目及产品</h4><p>项目及产品创建时保留默认选项即可</p><h4 id="数据模板"><a href="#数据模板" class="headerlink" title="数据模板"></a>数据模板</h4><p>产品界面点击“数据模板”，点击“导入json”，导入如下的json代码</p><pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span>  <span class="token property">"version"</span><span class="token operator">:</span> <span class="token string">"1.0"</span><span class="token punctuation">,</span>  <span class="token property">"profile"</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token property">"ProductId"</span><span class="token operator">:</span> <span class="token string">"BDDSF87WEA"</span><span class="token punctuation">,</span>    <span class="token property">"CategoryId"</span><span class="token operator">:</span> <span class="token string">"1"</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token property">"properties"</span><span class="token operator">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">{</span>      <span class="token property">"id"</span><span class="token operator">:</span> <span class="token string">"ch20_ppm_value"</span><span class="token punctuation">,</span>      <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"甲醛浓度值"</span><span class="token punctuation">,</span>      <span class="token property">"desc"</span><span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">,</span>      <span class="token property">"mode"</span><span class="token operator">:</span> <span class="token string">"r"</span><span class="token punctuation">,</span>      <span class="token property">"define"</span><span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"float"</span><span class="token punctuation">,</span>        <span class="token property">"min"</span><span class="token operator">:</span> <span class="token string">"0"</span><span class="token punctuation">,</span>        <span class="token property">"max"</span><span class="token operator">:</span> <span class="token string">"2"</span><span class="token punctuation">,</span>        <span class="token property">"start"</span><span class="token operator">:</span> <span class="token string">"0"</span><span class="token punctuation">,</span>        <span class="token property">"step"</span><span class="token operator">:</span> <span class="token string">"0.001"</span><span class="token punctuation">,</span>        <span class="token property">"unit"</span><span class="token operator">:</span> <span class="token string">"ppm(mg/m3)"</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      <span class="token property">"required"</span><span class="token operator">:</span> <span class="token boolean">false</span>    <span class="token punctuation">}</span>  <span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token property">"events"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token property">"actions"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre><h4 id="创建设备"><a href="#创建设备" class="headerlink" title="创建设备"></a>创建设备</h4><p>点击“设备调试”，进入后点击“新建设备”，创建成功后进入设备可以看到产品ID、设备名称、设备密钥等相关信息；</p><h3 id="传感器端操作"><a href="#传感器端操作" class="headerlink" title="传感器端操作"></a>传感器端操作</h3><p>进入 &lt; TencentOS-tiny\board\TencentOS_tiny_EVB_G0\KEIL\mqtt_iot_explorer_tc_ch20_oled&gt; 目录，打开TencentOS_tiny.uvprojx工程。</p><h4 id="修改Wifi接入信息"><a href="#修改Wifi接入信息" class="headerlink" title="修改Wifi接入信息"></a>修改Wifi接入信息</h4><p>编辑<code>mqtt_iot_explorer_tc_ch20_oled.c</code>文件，修改<code>esp8266_tencent_firmware_join_ap</code>函数中的要接入的WiFi名称和密码</p><img src="/xyzhangblog/2020/10/01/iot/tencentostiny-jia-quan-chuan-gan-qi/tencentostiny-ti-yan/image-20201001200336241.png" class="" title="image-20201001200336241"><h4 id="修改云端对接信息"><a href="#修改云端对接信息" class="headerlink" title="修改云端对接信息"></a>修改云端对接信息</h4><p>修改文件中的宏定义，对应腾讯云中的配置信息</p><img src="/xyzhangblog/2020/10/01/iot/tencentostiny-jia-quan-chuan-gan-qi/tencentostiny-ti-yan/image-20201001200710678.png" class="" title="image-20201001200710678"><p><del><strong>此处可自行发挥修改程序代码，实现更加复杂有趣的功能</strong></del></p><h4 id="编译下载"><a href="#编译下载" class="headerlink" title="编译下载"></a>编译下载</h4><p>编译完成-&gt;进入工程配置界面-&gt;选择debug选项-&gt;选择ST-Link Debugger-&gt;点击settings 该页面中的Unit选择ST-Link/V2，Port选择SW，点击确认保存配置；</p><img src="/xyzhangblog/2020/10/01/iot/tencentostiny-jia-quan-chuan-gan-qi/tencentostiny-ti-yan/@9ZW3%60FJ%60Z9RJ9%60LLK7AO8A.png" class="" title="img"><p>回到主界面点击下载；</p><h4 id="使用串口助手查看日志"><a href="#使用串口助手查看日志" class="headerlink" title="使用串口助手查看日志"></a>使用串口助手查看日志</h4><p>打开串口助手后，点击打开串口，点击开发板上的reset按钮，程序开始运行，可在主界面中查看运行日志</p><p>WiFi连接成功</p><img src="/xyzhangblog/2020/10/01/iot/tencentostiny-jia-quan-chuan-gan-qi/tencentostiny-ti-yan/U1%5B2$YTXDK@T0G@VTI01PSP.png" class="" title="img"><p>接入云平台成功</p><img src="/xyzhangblog/2020/10/01/iot/tencentostiny-jia-quan-chuan-gan-qi/tencentostiny-ti-yan/image-20201001204024547.png" class="" title="image-20201001204024547"><p>上述步骤完成后即可回到腾讯云界面查看数据上报情况</p><h2 id="0x05-成品展示"><a href="#0x05-成品展示" class="headerlink" title="0x05. 成品展示"></a>0x05. 成品展示</h2><ul><li>开发板</li></ul><img src="/xyzhangblog/2020/10/01/iot/tencentostiny-jia-quan-chuan-gan-qi/tencentostiny-ti-yan/image-20201001215542720.png" class="" title="image-20201001215542720"><ul><li>腾讯云数据展示界面</li></ul><img src="/xyzhangblog/2020/10/01/iot/tencentostiny-jia-quan-chuan-gan-qi/tencentostiny-ti-yan/image-20201001215415580.png" class="" title="image-20201001215415580"><ul><li>腾讯连连小程序数据展示界面</li></ul><img src="/xyzhangblog/2020/10/01/iot/tencentostiny-jia-quan-chuan-gan-qi/tencentostiny-ti-yan/image-20201001215931807.png" class="" title="image-20201001215931807"><ul><li>腾讯连连公众号数据报警界面</li></ul><img src="/xyzhangblog/2020/10/01/iot/tencentostiny-jia-quan-chuan-gan-qi/tencentostiny-ti-yan/image-20201001215758591.png" class="" title="image-20201001215758591"><h2 id="0x06-后记"><a href="#0x06-后记" class="headerlink" title="0x06. 后记"></a>0x06. 后记</h2><p>感谢 @supowang 大佬提供的极其详细的<a href="http://mk.oa.com/note/817">教程</a>，本文中大部分内容来自于其所写的教程步骤，另外添加了少部分自己在实践过程中的踩坑记录，后续有时间会尝试接入其他传感器完成更复杂更好玩的实践。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> IoT </tag>
            
            <tag> TencentOS-Tiny </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Block使用总结</title>
      <link href="/xyzhangblog/2020/09/24/ios-kai-fa/block-shi-yong-zong-jie/block-shi-yong-zong-jie/"/>
      <url>/xyzhangblog/2020/09/24/ios-kai-fa/block-shi-yong-zong-jie/block-shi-yong-zong-jie/</url>
      
        <content type="html"><![CDATA[<h3 id="Block应用场景"><a href="#Block应用场景" class="headerlink" title="Block应用场景"></a>Block应用场景</h3><ol><li><p>响应事件</p><blockquote><p>需求：UIViewController中使用UICollectionView构造集合视图，在集合视图中自定义Cell，每个Cell中有一个按钮，需要监听该按钮并对其做出相应</p></blockquote><p>在CellView中声明Block类型的属性，在按钮点击事件中调用该block</p><pre class=" language-objective-c"><code class="language-objective-c">//按钮点击Block@property (nonatomic, copy) void (^btnClickedBlock)(void);// 激活事件#pragma mark - 按钮点击事件- (IBAction)btnClickedAction:(UIButton *)sender {    if (self.btnClickedBlock) {        self.btnClickedBlock();    }}</code></pre><p>在ViewController中调用UICollectionView生成cell的代理方法<code>- (UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath</code>时，使用setter方法设置CellView中的block属性，其中包含按钮点击后执行的逻辑。—可以不在定义CellView时确定其执行逻辑，而是通过外部的setter方法确定</p><pre class=" language-objective-c"><code class="language-objective-c">// 设置cell 响应事件cell.btnClickedBlock = ^(UIButton *sender) {    // 执行逻辑};</code></pre></li><li><p>传递数据</p><blockquote><p>在UICollectionView中获取选中Cell的序号，根据选中的Cell执行不同逻辑</p></blockquote><pre class=" language-objective-c"><code class="language-objective-c">@property (strong, nonatomic) void (^handleDidSelectedItem)(int indexPath);- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath{    [tableView deselectRowAtIndexPath:indexPath animated:YES];    _handleDidSelectedItem ? _handleDidSelectedItem(indexPath) : NULL;}</code></pre></li></ol><h3 id="Block使用注意事项"><a href="#Block使用注意事项" class="headerlink" title="Block使用注意事项"></a>Block使用注意事项</h3><ol><li><p>局部变量与__block修饰符</p><p>block会在所在函数中捕获局部变量，但无法修改局部变量，可以修改全局变量、静态变量。</p><ul><li>不能修改局部变量：block捕获的是局部变量的const值，只是名字一样无法修改，如果想修改局部变量可以在定义时使用__block修饰。</li><li>可以修改静态变量：静态变量属于类，可以在block中调用</li></ul></li><li><p>循环引用问题</p><p>Self持有Block对象, 同时在Block内部又调用了Self, 导致了Self持有Block, Block又持有Self，那就会引起循环引用</p><ul><li><p>TestCycleRetain.m</p><pre class=" language-objective-c"><code class="language-objective-c">- (void) dealloc {    NSLog(@"no cycle retain");} - (id) init {    self = [super init];    if (self) {        #if TestCycleRetainCase1        //会循环引用        self.myblock = ^{            [self doSomething];        };        #endif NSLog(@"myblock is %@", self.myblock);    }    return self;} </code></pre></li></ul><p>循环引用的避免：声明一个self的弱指针，在block中引用该弱指针</p><pre class=" language-objective-c"><code class="language-objective-c">                #elif TestCycleRetainCase3        //不会循环引用        __weak TestCycleRetain * weakSelf = self;        self.myblock = ^{            [weakSelf doSomething];        };</code></pre><p>上述使用block中存在一个隐患，不知道self什么时候会被释放，为了保证在block中不会被释放，需要配合strong来使用</p><pre class=" language-objective-c"><code class="language-objective-c">__weak __typeof(self) weakSelf = self; self.testBlock =  ^{    __strong __typeof(weakSelf) strongSelf = weakSelf;       [strongSelf test]; });</code></pre><blockquote><p>From: Raven</p><p>以上操作带来一个疑问:<strong>通过弱引用接触循环引用的Self, 如果在Block内部再强引用, 岂不是又循环引用了吗?到底是如何延长Self的生命周期的?</strong></p><p><strong>解答</strong>:</p><p>block被赋值到<code>self</code>的成员变量时, arc下系统会将该block从栈区拷贝到堆区, 此时block会捕获它所用到的变量使用<code>__weak</code>可以保证block和<code>self</code>之间不会发生循环引用, 而在Block的代码块内声明<code>_ _strong</code>指针, 将会对self产生一个强引用延迟self的释放, 但和直接使用<code>self</code>所不同的是, <strong>在Block内声明的指针会在Block的作用域外销毁</strong>, 因此这个循环引用只会持续到block执行完毕为止, 当block执行完毕, strongSelf被销毁, <code>self</code>不再被Block所持有, 就可以顺利释放了.</p></blockquote></li></ol><ol start="3"><li><p>并不是所有Block里面的self都需要weak</p><ul><li><p>调用系统方法：</p><pre class=" language-objective-c"><code class="language-objective-c">[UIView animateWithDuration:0.5 animations:^{        NSLog(@"%@", self);}];</code></pre><p>这个block本身存在于静态方法中，虽然block对self强引用，但self不持有该静态方法，所以完全可以在block内部使用self</p></li></ul></li></ol><h3 id="block与内存管理"><a href="#block与内存管理" class="headerlink" title="block与内存管理"></a>block与内存管理</h3><p>根据Block在内存中的位置分为三种类型：</p><ul><li>NSGlobalBlock：全局区block，设置在程序的数据区域中</li><li>NSStackBlock：栈区，超出变量作用域则栈上的Block和__block变量都被销毁</li><li>NSMallocBlock：堆区，在变量作用域结束时不受影响</li></ul><ol><li><p>位于全局区：GlobalBlock</p><p>生成在全局区的block的情况：</p><ul><li><p>直接将block定义为全局变量</p><pre class=" language-objective-c"><code class="language-objective-c">void(^block)(void) = ^ { NSLog(@"Global Block");};int main() {}</code></pre></li></ul></li><li><p>位于栈内存：StackBlock –最常见的block</p><pre class=" language-objective-c"><code class="language-objective-c">NSInteger i = 10; block = ^{      NSLog(@"%ld", i); };block;</code></pre></li><li><p>位于堆内存：MallocBlock</p><p>堆中block无法直接创建，需要执行copy后才能放入堆中</p></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Block </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
