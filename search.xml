<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hello World</title>
      <link href="/xyzhangblog/2020/10/02/hello-world/"/>
      <url>/xyzhangblog/2020/10/02/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Block使用总结</title>
      <link href="/xyzhangblog/2020/09/24/ios-kai-fa/block-shi-yong-zong-jie/block-shi-yong-zong-jie/"/>
      <url>/xyzhangblog/2020/09/24/ios-kai-fa/block-shi-yong-zong-jie/block-shi-yong-zong-jie/</url>
      
        <content type="html"><![CDATA[<h3 id="Block应用场景"><a href="#Block应用场景" class="headerlink" title="Block应用场景"></a>Block应用场景</h3><ol><li><p>响应事件</p><blockquote><p>需求：UIViewController中使用UICollectionView构造集合视图，在集合视图中自定义Cell，每个Cell中有一个按钮，需要监听该按钮并对其做出相应</p></blockquote><p>在CellView中声明Block类型的属性，在按钮点击事件中调用该block</p><pre class=" language-objective-c"><code class="language-objective-c">//按钮点击Block@property (nonatomic, copy) void (^btnClickedBlock)(void);// 激活事件#pragma mark - 按钮点击事件- (IBAction)btnClickedAction:(UIButton *)sender {    if (self.btnClickedBlock) {        self.btnClickedBlock();    }}</code></pre><p>在ViewController中调用UICollectionView生成cell的代理方法<code>- (UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath</code>时，使用setter方法设置CellView中的block属性，其中包含按钮点击后执行的逻辑。—可以不在定义CellView时确定其执行逻辑，而是通过外部的setter方法确定</p><pre class=" language-objective-c"><code class="language-objective-c">// 设置cell 响应事件cell.btnClickedBlock = ^(UIButton *sender) {    // 执行逻辑};</code></pre></li><li><p>传递数据</p><blockquote><p>在UICollectionView中获取选中Cell的序号，根据选中的Cell执行不同逻辑</p></blockquote><pre class=" language-objective-c"><code class="language-objective-c">@property (strong, nonatomic) void (^handleDidSelectedItem)(int indexPath);- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath{    [tableView deselectRowAtIndexPath:indexPath animated:YES];    _handleDidSelectedItem ? _handleDidSelectedItem(indexPath) : NULL;}</code></pre></li></ol><h3 id="Block使用注意事项："><a href="#Block使用注意事项：" class="headerlink" title="Block使用注意事项："></a>Block使用注意事项：</h3><ol><li><p>局部变量与__block修饰符</p><p>block会在所在函数中捕获局部变量，但无法修改局部变量，可以修改全局变量、静态变量。</p><ul><li>不能修改局部变量：block捕获的是局部变量的const值，只是名字一样无法修改，如果想修改局部变量可以在定义时使用__block修饰。</li><li>可以修改静态变量：静态变量属于类，可以在block中调用</li></ul></li><li><p>循环引用问题</p><p>Self持有Block对象, 同时在Block内部又调用了Self, 导致了Self持有Block, Block又持有Self，那就会引起循环引用</p><ul><li><p>TestCycleRetain.m</p><pre class=" language-objective-c"><code class="language-objective-c">- (void) dealloc {    NSLog(@"no cycle retain");} - (id) init {    self = [super init];    if (self) {        #if TestCycleRetainCase1        //会循环引用        self.myblock = ^{            [self doSomething];        };        #endif NSLog(@"myblock is %@", self.myblock);    }    return self;} </code></pre></li></ul><p>循环引用的避免：声明一个self的弱指针，在block中引用该弱指针</p><pre class=" language-objective-c"><code class="language-objective-c">                #elif TestCycleRetainCase3        //不会循环引用        __weak TestCycleRetain * weakSelf = self;        self.myblock = ^{            [weakSelf doSomething];        };</code></pre><p>上述使用block中存在一个隐患，不知道self什么时候会被释放，为了保证在block中不会被释放，需要配合strong来使用</p><pre class=" language-objective-c"><code class="language-objective-c">__weak __typeof(self) weakSelf = self; self.testBlock =  ^{    __strong __typeof(weakSelf) strongSelf = weakSelf;       [strongSelf test]; });</code></pre><blockquote><p>From: Raven</p><p>以上操作带来一个疑问:<strong>通过弱引用接触循环引用的Self, 如果在Block内部再强引用, 岂不是又循环引用了吗?到底是如何延长Self的生命周期的?</strong></p><p><strong>解答</strong>:</p><p>block被赋值到<code>self</code>的成员变量时, arc下系统会将该block从栈区拷贝到堆区, 此时block会捕获它所用到的变量使用<code>__weak</code>可以保证block和<code>self</code>之间不会发生循环引用, 而在Block的代码块内声明<code>_ _strong</code>指针, 将会对self产生一个强引用延迟self的释放, 但和直接使用<code>self</code>所不同的是, <strong>在Block内声明的指针会在Block的作用域外销毁</strong>, 因此这个循环引用只会持续到block执行完毕为止, 当block执行完毕, strongSelf被销毁, <code>self</code>不再被Block所持有, 就可以顺利释放了.</p></blockquote></li></ol><ol start="3"><li><p>并不是所有Block里面的self都需要weak</p><ul><li><p>调用系统方法：</p><pre class=" language-objective-c"><code class="language-objective-c">[UIView animateWithDuration:0.5 animations:^{        NSLog(@"%@", self);}];</code></pre><p>这个block本身存在于静态方法中，虽然block对self强引用，但self不持有该静态方法，所以完全可以在block内部使用self</p></li></ul></li></ol><h3 id="block与内存管理："><a href="#block与内存管理：" class="headerlink" title="block与内存管理："></a>block与内存管理：</h3><p>根据Block在内存中的位置分为三种类型：</p><ul><li>NSGlobalBlock：全局区block，设置在程序的数据区域中</li><li>NSStackBlock：栈区，超出变量作用域则栈上的Block和__block变量都被销毁</li><li>NSMallocBlock：堆区，在变量作用域结束时不受影响</li></ul><ol><li><p>位于全局区：GlobalBlock</p><p>生成在全局区的block的情况：</p><ul><li><p>直接将block定义为全局变量</p><pre class=" language-objective-c"><code class="language-objective-c">void(^block)(void) = ^ { NSLog(@"Global Block");};int main() {}</code></pre></li></ul></li><li><p>位于栈内存：StackBlock –最常见的block</p><pre class=" language-objective-c"><code class="language-objective-c">NSInteger i = 10; block = ^{      NSLog(@"%ld", i); };block;</code></pre></li><li><p>位于堆内存：MallocBlock</p><p>堆中block无法直接创建，需要执行copy后才能放入堆中</p></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Block </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>My new Pages</title>
      <link href="/xyzhangblog/2020/08/27/my-new-pages/"/>
      <url>/xyzhangblog/2020/08/27/my-new-pages/</url>
      
        <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
