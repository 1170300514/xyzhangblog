<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>二叉树算法总结</title>
      <link href="/xyzhangblog/2020/11/24/bian-cheng-ji-chu/shu-zong-jie/er-cha-shu-suan-fa-zong-jie/"/>
      <url>/xyzhangblog/2020/11/24/bian-cheng-ji-chu/shu-zong-jie/er-cha-shu-suan-fa-zong-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="二叉树种类"><a href="#二叉树种类" class="headerlink" title="二叉树种类"></a>二叉树种类</h1><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> Java </tag>
            
            <tag> 算法 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表算法总结</title>
      <link href="/xyzhangblog/2020/11/24/bian-cheng-ji-chu/lian-biao-zong-jie/lian-biao-zong-jie/"/>
      <url>/xyzhangblog/2020/11/24/bian-cheng-ji-chu/lian-biao-zong-jie/lian-biao-zong-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="虚拟头节点"><a href="#虚拟头节点" class="headerlink" title="虚拟头节点"></a>虚拟头节点</h2><p>Solution203.移出链表元素</p><p>使用虚拟头节点避免每次遇到头节点删除等情况再做特殊处理</p><h2 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h2><p>Solution206.反转链表 </p><p><a href="https://leetcode-cn.com/problems/reverse-linked-list/">https://leetcode-cn.com/problems/reverse-linked-list/</a></p><p>迭代法：</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> Java </tag>
            
            <tag> 算法 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法总结</title>
      <link href="/xyzhangblog/2020/11/20/bian-cheng-ji-chu/pai-xu-suan-fa-zong-jie/pai-xu-suan-fa-zong-jie/"/>
      <url>/xyzhangblog/2020/11/20/bian-cheng-ji-chu/pai-xu-suan-fa-zong-jie/pai-xu-suan-fa-zong-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>归并排序基于分治思想，分治思想在递归上有三个步骤</p><ul><li>分解(Divide)：将n个元素分成两个含n/2的元素的子序列</li><li>解决(Conquer)：用合并排序法对两个子序列递归的排序</li><li>合并(Combine)：合并两个已排序的子序列得到排序结果</li></ul><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>平均时间复杂度：O(nlogn) // 无论元素在什么情况下都要做分割合并的步骤，开销的时间是不变的</p><p>最佳时间复杂度：O(nlogn)</p><p>最差时间复杂度：O(nlogn)</p><p>空间复杂度：O(n)</p><p>排序方式：外排序</p><p>稳定性：稳定</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">sortArray</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">mergeSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 归并排序</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>            mid <span class="token operator">=</span> <span class="token punctuation">(</span>left <span class="token operator">+</span> right<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token function">mergeSort</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> left<span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">mergeSort</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">merge</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> left<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> mid<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> lenleft <span class="token operator">=</span> mid<span class="token operator">-</span>left<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 包含mid和left因此需要+1</span>        <span class="token keyword">int</span> lenright <span class="token operator">=</span> right<span class="token operator">-</span>mid<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 申请新数组</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> leftArray <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>lenleft<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> rightArray <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>lenright<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 新数组赋值</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> lenleft<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            leftArray<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>left<span class="token operator">+</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> lenright<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            rightArray<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>mid<span class="token operator">+</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 从mid+1到right才是划分后的数组</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// merge</span>        <span class="token keyword">int</span> leftindex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> rightindex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>leftindex <span class="token operator">&lt;</span> lenleft <span class="token operator">&amp;&amp;</span> rightindex <span class="token operator">&lt;</span> lenright<span class="token punctuation">)</span>  <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>leftArray<span class="token punctuation">[</span>leftindex<span class="token punctuation">]</span> <span class="token operator">&lt;</span> rightArray<span class="token punctuation">[</span>rightindex<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                array<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">=</span> leftArray<span class="token punctuation">[</span>leftindex<span class="token punctuation">]</span><span class="token punctuation">;</span>                left<span class="token operator">++</span><span class="token punctuation">;</span>                leftindex<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                array<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">=</span> rightArray<span class="token punctuation">[</span>rightindex<span class="token punctuation">]</span><span class="token punctuation">;</span>                left<span class="token operator">++</span><span class="token punctuation">;</span>                rightindex<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>leftindex <span class="token operator">&lt;</span> lenleft<span class="token punctuation">)</span> <span class="token punctuation">{</span>            array<span class="token punctuation">[</span>left<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> leftArray<span class="token punctuation">[</span>leftindex<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>rightindex <span class="token operator">&lt;</span> lenright<span class="token punctuation">)</span> <span class="token punctuation">{</span>            array<span class="token punctuation">[</span>left<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> rightArray<span class="token punctuation">[</span>rightindex<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><p>参考资料：</p><p><a href="https://www.cnblogs.com/chengxiao/p/6194356.html">https://www.cnblogs.com/chengxiao/p/6194356.html</a></p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h3 id="基本思想-1"><a href="#基本思想-1" class="headerlink" title="基本思想"></a>基本思想</h3><p>分治：选择数组中某个数作为基数，通过一趟排序将要排序的数据分割成独立的两部分，其中一部分所有数都比基数小，另外一部分都比基数大，然后再按此方法对这两部分数据分别进行快排</p><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>平均时间复杂度：O(nlogn)</p><p>最佳时间复杂度：O(nlogn)</p><p>最差时间复杂度：O(n2) // 元素都分到一个子序列（序列本身为升序或降序排列）</p><p>空间复杂度：O(logn)</p><p>排序方式：内排序</p><p>稳定性：不稳定</p><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">sortArray</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> p <span class="token operator">=</span> <span class="token function">partition</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span>l<span class="token punctuation">,</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> l<span class="token punctuation">,</span> p<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> p<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">partition</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> pivot <span class="token operator">=</span> nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> l<span class="token punctuation">,</span> right <span class="token operator">=</span> r<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 从右向左找到第一个小于基数的数字停下</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">>=</span> pivot <span class="token operator">&amp;&amp;</span> left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>                right<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// 从左向右找到第一个大于基数的数字停下</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> pivot <span class="token operator">&amp;&amp;</span>  left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>                left<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 划分结束将基数值替换到中间位置 此时位于l的元素一定比基准值小（先从后向前遍历的原因）</span>        <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> left<span class="token punctuation">,</span> l<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> left<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> temp <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h3 id="优化方法"><a href="#优化方法" class="headerlink" title="优化方法"></a>优化方法</h3><ol><li><p>选择枢纽元</p><ul><li>选第一个或最后一个</li><li>随机选择</li><li>三数中值分割法</li></ul></li><li><p>分析重复元素处理</p></li><li><p>递归分成小数组时使用插入排序</p><p><strong>对于小数组（N&lt;=20）的输入序列，快速排序不如<a href="https://juejin.im/post/6844903821789888520">插入排序</a>；</strong>并且在我们上面的优化中，采用三数中值分割时，递归得到的结果可以是只有一个，或者两个元素，这时会有错误。所以，继续优化是将小的序列用插入排序代替，这会减少大约15%的运行时间。<strong>较好的截止范围是10</strong>（其实5-20产生的效果差不多）。</p></li></ol><p>选择插入一个是从已排序中找，一个是从未排序中找插入到已排序序列中</p><p>参考资料</p><p><a href="https://juejin.cn/post/6844903837749215246">https://juejin.cn/post/6844903837749215246</a></p><p><a href="https://zhuanlan.zhihu.com/p/57436476">https://zhuanlan.zhihu.com/p/57436476</a></p><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><h3 id="基本思想-2"><a href="#基本思想-2" class="headerlink" title="基本思想"></a>基本思想</h3><p>先在未排序序列中找到最小的将其交换到序列的初始位置，以后每次都再从未排序序列中找到最小的交换到已排序序列的末尾，此时每次从未排序序列中找到最小的就是已排序序列中最大的。</p><h3 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>平均时间复杂度：O(n2) // 每次都需要在剩余序列中选择最小的元素，与元素的初始排列无关</p><p>最佳时间复杂度：O(n2)</p><p>最差时间复杂度：O(n2)</p><p>空间复杂度：O(1)</p><p>排序方式：内排序</p><p>稳定性：不稳定</p><h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">// 选择排序</span>    <span class="token comment" spellcheck="true">// 遍历从未排序的序列中每次找到最小值，找到后与未排序序列第一个值交换</span>    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">selectSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> minValue<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> array<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            minValue <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> array<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>array<span class="token punctuation">[</span>minValue<span class="token punctuation">]</span> <span class="token operator">></span> array<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    minValue <span class="token operator">=</span> j<span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">int</span> temp <span class="token operator">=</span> array<span class="token punctuation">[</span>minValue<span class="token punctuation">]</span><span class="token punctuation">;</span>            array<span class="token punctuation">[</span>minValue<span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            array<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h3 id="基本思想-3"><a href="#基本思想-3" class="headerlink" title="基本思想"></a>基本思想</h3><p>将数据分为两部分，有序部分和无序部分，依次将无序元素插入到有序部分的特定位置，直到所有元素有序。</p><p>插入排序分为<strong>直接插入、二分插入、链表插入</strong>等。</p><p>Q：与<strong>选择排序</strong>的<strong>相同点</strong>？<br> A：当前索引左边的所有元素都是有序的，但它们的最终位置还不确定，为了给更小的元素腾出空间，它们可能会被移动。当索引到达数组的右端时，数组排序就完成了。</p><p>Q：与<strong>选择排序</strong>的<strong>不同点</strong>？<br> A：<strong>插入排序</strong>所需的时间取决于输入中元素的<strong>初始顺序</strong>。速度：元素已经有序（或接近有序）的数组 &gt; 随机顺序的数组</p><h3 id="复杂度分析-3"><a href="#复杂度分析-3" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>平均时间复杂度：O(n2)</p><p>最佳时间复杂度：O(n) // 元素本来就有序，只需要遍历一次即可。当倒置的数量很少时，比其他的排序算法都要快（对于部分有序的很有效）</p><p>最差时间复杂度：O(n2)</p><p>空间复杂度：O(1)</p><p>排序方式：内排序</p><p>稳定性：稳定</p><h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">// 插入排序</span>    <span class="token comment" spellcheck="true">// 依次向后遍历，每遇到一个元素就将其插入到数组的合适位置，其余元素向后移动</span>    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">insertSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> array<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> index <span class="token operator">=</span> i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>ans <span class="token operator">=</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>index <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> ans <span class="token operator">&lt;</span> array<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                array<span class="token punctuation">[</span>index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>                index<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            array<span class="token punctuation">[</span>index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> ans<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><h3 id="优化方法TODO"><a href="#优化方法TODO" class="headerlink" title="优化方法TODO"></a>优化方法TODO</h3><p>查找插入位置时使用二分查找方式</p><p>参考资料：</p><p><a href="https://www.jianshu.com/p/6d55ac4b72b4">https://www.jianshu.com/p/6d55ac4b72b4</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> Java </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java泛型详解</title>
      <link href="/xyzhangblog/2020/11/19/java/java-fan-xing-xiang-jie/"/>
      <url>/xyzhangblog/2020/11/19/java/java-fan-xing-xiang-jie/</url>
      
        <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> Java </tag>
            
            <tag> 泛型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工作中如何快速入手新项目</title>
      <link href="/xyzhangblog/2020/11/06/bian-cheng-xiang-guan-ji-zhu/ru-he-kuai-su-ru-shou-xin-xiang-mu/ru-he-kuai-su-ru-shou-xin-xiang-mu/"/>
      <url>/xyzhangblog/2020/11/06/bian-cheng-xiang-guan-ji-zhu/ru-he-kuai-su-ru-shou-xin-xiang-mu/ru-he-kuai-su-ru-shou-xin-xiang-mu/</url>
      
        <content type="html"><![CDATA[<blockquote><p>实习结束返校前，看到了一位同事写的公众号文章，文章主要讲解了一些工作上入手新项目的技巧，结合这段实习经历，自己也发现上手新项目的速度往往决定了你是否可以通过实习转正，因为从实习到转正最多也只有3个月的时间，上手项目的速度直接决定了你的工作产出；同时，在面试时也会有面试官着重考察这方面的能力，因此决定总结下与之相关的方式方法，无论是在面试还是今后工作上都能得以应用</p></blockquote><h2 id="接手新项目出现的问题"><a href="#接手新项目出现的问题" class="headerlink" title="接手新项目出现的问题"></a>接手新项目出现的问题</h2><p><strong>1.项目重点不明确</strong></p><p>一开始面对各种需求 ，很容易陷入工作细节里不可自拔，有时候跑偏了也不自知。或者做一些挠痒痒的工作，没有触及核心问题，效率非常低下。</p><p><strong>2.工具使用不熟练</strong></p><p>接手的新项目跟最近两年里做的项目很不同，使用的平台、工具也很不一样。熟悉这些平台工具的操作稍微需要花点儿时间。</p><p><strong>3.待看资料多而杂</strong></p><p>新接手的项目是从别的团队转过来的，已经积累了很长时间，因此有很多背景资料需要熟悉，包括产品说明文档、数据说明文档、各种平台使用说明等等。</p><p><strong>4.小需求应接不暇</strong></p><p>由于一开始对项目不熟悉，没有一个全局观，对项目各种数据的认识和理解也不是很深刻，一开始接数据的需求总处于一种被动的状态。因为没有全局观、缺乏规划，很多需求都是一次性的，非常耗时。</p><p><strong>5.未知问题的困扰</strong></p><p>新项目总是会遇到以前从来没有遇到、别人也没有经验的问题。如果时间紧急，就很容易陷入焦虑中。</p><h2 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h2><h3 id="做好项目管理跟进"><a href="#做好项目管理跟进" class="headerlink" title="做好项目管理跟进"></a>做好项目管理跟进</h3><p>这里说的项目管理是针对工作内容的项目管理</p><ul><li>具体做法：创建Excel表格，把项目中设计的所有数据分析相关的重点工作都列举出来，然后排期，每周跟进</li></ul><p>这样的好处是，保证自己在工作的大方向上不会跑偏，并且每周有个小目标压着，工作效率也会高一些。</p><p>另外，工作重点事项这里需要跟项目组的核心人员多交流，加深对项目的理解，然后紧紧围绕整个项目的KPI来确定自己的关键工作内容，为整个项目的KPI达成最大限度贡献自己的力量。</p><h3 id="构建工具百宝箱"><a href="#构建工具百宝箱" class="headerlink" title="构建工具百宝箱"></a>构建工具百宝箱</h3><p>针对工具不熟练，先使用二八法则，找到最常用的功能尽快上手。这个过程可以请教使用这个工具很熟练的老司机们，其他不常用的功能以后有空慢慢探索。</p><p>然后把最常用的功能、使用方法及账号密码记录在某个固定的地方。新项目涉及到的所有工具素材，我都会用同一个云笔记文件统一管理，然后收藏在浏览器最醒目的位置，每天开启工作的第一件事情就是打开这个收藏页保证能最快速调用工具开始干活。</p><h3 id="梳理材料并分类"><a href="#梳理材料并分类" class="headerlink" title="梳理材料并分类"></a>梳理材料并分类</h3><p>比如网页相关的，我会建在浏览器的一个收藏夹里，然后按照内容不同进行分类归档，保证用的时候可以快速找到。</p><p>文档资料，我也会根据内容进行分类归档。然后根据重要程度进行优先级排序，安排在日程里去看和理解。看的过程中，我会梳理重要信息，并记下自己的疑问与想法，然后找相关同事搞清楚。</p><p>这个步骤虽然很简单，整理起来也花不了多长时间，但是可以大大节约我的认知带宽，把省下来的意志力和时间花在更有价值的事情上。</p><h3 id="梳理需求统一规划"><a href="#梳理需求统一规划" class="headerlink" title="梳理需求统一规划"></a>梳理需求统一规划</h3><p>针对小需求应接不暇的问题，我的方法是：<strong>定期整理做过的数据需求，看看有没有什么共同点，找到共性，然后流程化run起来。</strong></p><p>但最终极的方法，还是要统一规划。但规划一般来自于对项目的深刻理解，一开始的琐碎小需求阶段正好可以为后期的规划提供素材。这么想了之后，我在前期做这些需求时也不会那么烦躁了。</p><p>最好的解决方案是，<strong>前期从琐碎小需求中积累经验，同时思考如何做整体规划。</strong>等经验积累的差不多时，整体规划也做得差不多了，然后一气呵成完成规划好的数据建设工作。最后，再用新的整体方案替换掉之前的临时方法，完美。</p><h3 id="拆解问题各个击破"><a href="#拆解问题各个击破" class="headerlink" title="拆解问题各个击破"></a>拆解问题各个击破</h3><p>针对项目中遇到的问题，<strong>我的方法是先去搜索有没有经验可以参考，使用谷歌搜索或者找有经验的同事问。</strong></p><p>如果都找不到，那就是一个真正的难题，这个时候我应该开心，因为如果解决了，我的工具百宝箱又可以添一笔资产了。</p><p>但一般情况下，这种场景是非常少的。真的遇上了，<strong>我最需要的可能就是一张纸、一支笔，然后找一个精力旺盛的安静时段，好好思考。</strong>有时一下子想不出来，就利用空闲时间的发散模式来帮助自己寻找灵感。大多数情况下，问题都会这样被解决掉。</p><p>另外一种工作的难题是隐蔽性的难题，看上去比较复杂和庞大。</p><p>但其实<strong>只要花时间思考下，这种问题是完全可以被拆解成多个小问题的，然后各个击破就好了。</strong></p><p>具体步骤是这样的，我会先找个精力好的时间段思考难题如何解决，这个阶段一般只需要拿一张白纸和笔就好了。</p><p>想好之后，<strong>我会针对这个难题专门建立一个Excel表来跟进。然后把拆解后的步骤记录下来，每个步骤都写上对应的方法、需要用到的资源以及可能的风险点，然后去跟进、执行，做完后记录状态。</strong></p><p>这样操作之后，尽管步骤可能会很多、很复杂，但因为我把所有的步骤记录在同一页文档上，就会形成一种全局观，并且我有记录跟进状态，所以一点也不乱。</p><p>拆解、记录真的是应对复杂问题的最好方法，每次遇到难题我都是用这个方法解决的，真是屡试不爽。</p><p>其实，很多时候难题只是看上去难而已，大脑一下子处理不了那么多层的信息。拆解和记录，其实相当于帮你节省大脑的计算资源，一次只专注一个核心问题，所以很容易就能解决。</p><p>参考资料：</p><p><a href="https://mp.weixin.qq.com/s/Z4sntS4H5IsUCeVwcJkVGA">https://mp.weixin.qq.com/s/Z4sntS4H5IsUCeVwcJkVGA</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 工作 </tag>
            
            <tag> 经验总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[GCD]使用dispatch_once实现单例</title>
      <link href="/xyzhangblog/2020/11/06/ios-kai-fa/gcd-shi-yong-dispatch-once-shi-xian-dan-li/gcd-shi-yong-dispatch-once-shi-xian-dan-li/"/>
      <url>/xyzhangblog/2020/11/06/ios-kai-fa/gcd-shi-yong-dispatch-once-shi-xian-dan-li/gcd-shi-yong-dispatch-once-shi-xian-dan-li/</url>
      
        <content type="html"><![CDATA[<h2 id="使用dispatch-once执行只需运行一次的线程安全代码"><a href="#使用dispatch-once执行只需运行一次的线程安全代码" class="headerlink" title="使用dispatch_once执行只需运行一次的线程安全代码"></a>使用dispatch_once执行只需运行一次的线程安全代码</h2><p>单例模式（singleton）对 Objective-C 开发者而言并不陌生，常见的实现方式为：在类编写名为<code>sharedInstance</code>的方法，该方法只会返回全类共用的单例实例，而不会在每次调用时都创建新的实例。假设有一个类叫<code>TestClass</code>，那么这个共享实例一般会这么写：</p><pre class=" language-objectivec"><code class="language-objectivec"><span class="token operator">+</span> <span class="token punctuation">(</span>id<span class="token punctuation">)</span>sharedInstance <span class="token punctuation">{</span>    <span class="token keyword">static</span> TestClass <span class="token operator">*</span>sharedInstance <span class="token operator">=</span> nil<span class="token punctuation">;</span>    <span class="token operator">@</span><span class="token function">synchronized</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>sharedInstance<span class="token punctuation">)</span> <span class="token punctuation">{</span>            sharedInstance <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token keyword">self</span> alloc<span class="token punctuation">]</span> init<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> sharedInstance<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>单例模式很容易引起激励讨论，Objective-C 的单例尤其如此。线程安全是大家争论的主要问题。为了保证线程安全，上述代码将创建单例实例的代码包裹在<strong>同步块</strong>里。无论是好是坏，反正这种实现方式很常用，这样的代码也随处可见。</p><p>不过，GCD 引入了一项特性，能使单例实现起来更加容易。所用的函数是：</p><pre class=" language-objectivec"><code class="language-objectivec"><span class="token keyword">void</span> <span class="token function">dispatch_once</span><span class="token punctuation">(</span>dispatch_once_t <span class="token operator">*</span>token<span class="token punctuation">,</span> dispatch_block_t block<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>此函数接受类型为<code>dispatch_once_t</code>的特殊参数，称其为<strong>标记</strong>（token），此外还接受 block 参数，对于给定 token 来说，该函数保证相关的 block 必定会执行，且仅执行一次。首次调用该函数时，必然会执行 block 的代码，最重要的一点在于，此操作完全是线程安全的。请注意，对于只需执行一次的块来说，每次调用函数时传入的 token 都必须是完全相同的。因此，开发者通常将标记变量声明在<code>static</code>或<code>global</code>作用域里。</p><p>上述实现单例模式所用的<code>sharedInstance</code>方法，可以用此函数来改写：</p><pre class=" language-objectivec"><code class="language-objectivec"><span class="token operator">+</span> <span class="token punctuation">(</span>id<span class="token punctuation">)</span>sharedInstance <span class="token punctuation">{</span>    <span class="token keyword">static</span> TestClass <span class="token operator">*</span>sharedInstance<span class="token punctuation">;</span>    <span class="token keyword">static</span> dispatch_once_t onceToken<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// typedef long dispatch_once_t;</span>    <span class="token function">dispatch_once</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>onceToken<span class="token punctuation">,</span> <span class="token operator">^</span><span class="token punctuation">{</span>        sharedInstance <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token keyword">self</span> alloc<span class="token punctuation">]</span> init<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> sharedInstance<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>使用<code>disptch_once</code>可以简化代码并且彻底保证线程安全，开发者根本无须担心加锁或同步。所有问题都由 GCD 在底层处理。由于每次调用时都必须使用完全相同的 token，所以 token 要声明成<code>static</code>。把该变量定义在<code>static</code>作用域中，可以保证编译器在每次执行<code>sharedInstance</code>方法时都会复用这个变量，而不会创建新变量。</p><p>此外，<code>dispatch_once</code>更高效。它没有使用重量级的同步机制，若是那样做的话，每次运行代码前都要获取锁，相反，此函数采用原子访问（atomic access）来查询标记，以判断其所对应的代码原来是否已经执行过。《Effective Objective-C 2.0》的作者在装有 64 位的 Mac OS X 10.8.2 系统的电脑上简单测试了性能，分别采用<code>@synchronized</code>方式及<code>dispatch_once</code>方式来实现<code>sharedInstance</code>，结果显示，后者的速度几乎是前者的 2 倍。</p><p>总结：</p><ol><li>经常需要编写<strong>只需执行一次的线程安全代码</strong>（thread-safe single-code execution），通过 GCD 提供的<code>dispatch_once</code>函数，很容易就能实现此功能。</li><li>token 应该声明在<code>static</code>或<code>global</code>中，这样的话，在把只需一次执行的块传给<code>dispatch_once</code>函数时，传进去的标记也是相同的。</li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://book.douban.com/subject/21370593/">Effective Objective-C 2.0</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> GCD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统（一）</title>
      <link href="/xyzhangblog/2020/10/25/ji-suan-ji-ji-chu/cao-zuo-xi-tong/cao-zuo-xi-tong-yi/"/>
      <url>/xyzhangblog/2020/10/25/ji-suan-ji-ji-chu/cao-zuo-xi-tong/cao-zuo-xi-tong-yi/</url>
      
        <content type="html"><![CDATA[<p><a href="https://mp.weixin.qq.com/s/i0PmP86iVv_-TlN8MLWIsw">https://mp.weixin.qq.com/s/i0PmP86iVv_-TlN8MLWIsw</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码编译时都做了什么？</title>
      <link href="/xyzhangblog/2020/10/20/ji-suan-ji-ji-chu/bian-yi-yuan-li/dai-ma-bian-yi-shi-du-zuo-liao-shi-me/dai-ma-bian-yi-shi-du-zuo-liao-shi-me/"/>
      <url>/xyzhangblog/2020/10/20/ji-suan-ji-ji-chu/bian-yi-yuan-li/dai-ma-bian-yi-shi-du-zuo-liao-shi-me/dai-ma-bian-yi-shi-du-zuo-liao-shi-me/</url>
      
        <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 编译原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>提升hexo博客写作效率</title>
      <link href="/xyzhangblog/2020/10/18/bian-cheng-xiang-guan-ji-zhu/ti-sheng-hexo-bo-ke-xie-zuo-xiao-lu/ti-sheng-hexo-bo-ke-xie-zuo-xiao-lu/"/>
      <url>/xyzhangblog/2020/10/18/bian-cheng-xiang-guan-ji-zhu/ti-sheng-hexo-bo-ke-xie-zuo-xiao-lu/ti-sheng-hexo-bo-ke-xie-zuo-xiao-lu/</url>
      
        <content type="html"><![CDATA[<ol><li>新建文章</li></ol><pre class=" language-bash"><code class="language-bash">hexo new post <span class="token string">"文章标题"</span></code></pre><p>为保证目录结构清晰易于查找，建议将生成的markdown文件放置在文件夹下<br>**<u>若有插入图片的需求需要在markdown文件的同级目录下新建同名文件夹，用于存储图片，文章中使用相对路径进行图片的引用（参考<a href="https://github.com/1170300514/xyzhangblog/tree/master/source/_posts/IoT/TencentOSTiny%E7%94%B2%E9%86%9B%E4%BC%A0%E6%84%9F%E5%99%A8">甲醛传感器</a>文章的路径设置方式）</u>**</p><ol start="2"><li><p>在文章头信息中添加summary字段用于首页展示，相当于次级标题</p><p>文章头信息有很多可配字段 详细如下：</p><p><code>Front-matter</code> 选项中的所有内容均为<strong>非必填</strong>的。但我仍然建议至少填写 <code>title</code> 和 <code>date</code> 的值。</p><table><thead><tr><th>配置选项</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>title</td><td><code>Markdown</code> 的文件标题</td><td>文章标题，强烈建议填写此选项</td></tr><tr><td>date</td><td>文件创建时的日期时间</td><td>发布时间，强烈建议填写此选项，且最好保证全局唯一</td></tr><tr><td>author</td><td>根 <code>_config.yml</code> 中的 <code>author</code></td><td>文章作者</td></tr><tr><td>img</td><td><code>featureImages</code> 中的某个值</td><td>文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如: <code>http://xxx.com/xxx.jpg</code></td></tr><tr><td>top</td><td><code>true</code></td><td>推荐文章（文章是否置顶），如果 <code>top</code> 值为 <code>true</code>，则会作为首页推荐文章</td></tr><tr><td>cover</td><td><code>false</code></td><td><code>v1.0.2</code>版本新增，表示该文章是否需要加入到首页轮播封面中</td></tr><tr><td>coverImg</td><td>无</td><td><code>v1.0.2</code>版本新增，表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片</td></tr><tr><td>password</td><td>无</td><td>文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 <code>password</code> 的值，该值必须是用 <code>SHA256</code> 加密后的密码，防止被他人识破。前提是在主题的 <code>config.yml</code> 中激活了 <code>verifyPassword</code> 选项</td></tr><tr><td>toc</td><td><code>true</code></td><td>是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 <code>config.yml</code> 中激活了 <code>toc</code> 选项</td></tr><tr><td>mathjax</td><td><code>false</code></td><td>是否开启数学公式支持 ，本文章是否开启 <code>mathjax</code>，且需要在主题的 <code>_config.yml</code> 文件中也需要开启才行</td></tr><tr><td>summary</td><td>无</td><td>文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要</td></tr><tr><td>categories</td><td>无</td><td>文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类</td></tr><tr><td>tags</td><td>无</td><td>文章标签，一篇文章可以多个标签</td></tr><tr><td>keywords</td><td>文章标题</td><td>文章关键字，SEO 时需要</td></tr><tr><td>reprintPolicy</td><td>cc_by</td><td>文章转载规则， 可以是 cc_by, cc_by_nd, cc_by_sa, cc_by_nc, cc_by_nc_nd, cc_by_nc_sa, cc0, noreprint 或 pay 中的一个</td></tr></tbody></table><p>以下为文章的 <code>Front-matter</code> 示例。</p><h3 id="最简示例"><a href="#最简示例" class="headerlink" title="最简示例"></a>最简示例</h3><pre><code>---title: typora-vue-theme主题介绍date: 2018-09-07 09:25:00---</code></pre><h3 id="最全示例"><a href="#最全示例" class="headerlink" title="最全示例"></a>最全示例</h3><pre><code>---title: typora-vue-theme主题介绍date: 2018-09-07 09:25:00author: 赵奇img: /source/images/xxx.jpgtop: truecover: truecoverImg: /images/1.jpgpassword: 8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92toc: falsemathjax: falsesummary: 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要categories: Markdowntags:  - Typora  - Markdown---</code></pre></li><li><p>文章内容撰写完成后使用hexo命令在本地运行</p><pre class=" language-bash"><code class="language-bash">hexo cleanhexo generatehexo server</code></pre><p>查看无误后push到github触发CI生成网页</p></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git强制拉取与推送</title>
      <link href="/xyzhangblog/2020/10/18/git/git-qiang-zhi-la-qu-yu-tui-song/git-qiang-zhi-la-qu-yu-tui-song/"/>
      <url>/xyzhangblog/2020/10/18/git/git-qiang-zhi-la-qu-yu-tui-song/git-qiang-zhi-la-qu-yu-tui-song/</url>
      
        <content type="html"><![CDATA[<h2 id="Git强制拉取"><a href="#Git强制拉取" class="headerlink" title="Git强制拉取"></a>Git强制拉取</h2><p>有时本地修改代码出现异常，需要将本地修改全部忽略，强制拉取远端</p><pre class=" language-bash"><code class="language-bash">// 方法1: 清空本地修改后 拉取远端代码<span class="token function">git</span> reset --hard<span class="token function">git</span> pull// 方法2: 直接拉取远端代码将HEAD指向master最新版本<span class="token function">git</span> fetch --all<span class="token function">git</span> reset --hard origin/master<span class="token function">git</span> pull</code></pre><h2 id="Git强制推送"><a href="#Git强制推送" class="headerlink" title="Git强制推送"></a>Git强制推送</h2><p>强制用本地代码覆盖远程仓库</p><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> push -f origin master</code></pre><h2 id="Git撤销commit"><a href="#Git撤销commit" class="headerlink" title="Git撤销commit"></a>Git撤销commit</h2><p>执行完commit后，想撤回commit，以下命令可以仅撤回commit不删除代码</p><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> reset --soft HEAD^</code></pre><h4 id="回滚次数"><a href="#回滚次数" class="headerlink" title="回滚次数"></a>回滚次数</h4><p>HEAD^的意思是上一个版本，也可以写成HEAD~1</p><p>如果你进行了2次commit，想都撤回，可以使用HEAD~2</p><h4 id="参数含义"><a href="#参数含义" class="headerlink" title="参数含义"></a>参数含义</h4><ol><li><p>–mixed </p><p>意思是：不删除工作空间改动代码，撤销commit，并且撤销git add . 操作</p><p>这个为默认参数,git reset –mixed HEAD^ 和 git reset HEAD^ 效果是一样的。</p></li><li><p>–soft </p><p>不删除工作空间改动代码，撤销commit，不撤销git add . </p></li><li><p>–hard</p><p>删除工作空间改动代码，撤销commit，撤销git add . </p><p>注意完成这个操作后，就恢复到了上一次的commit状态。</p></li></ol><h4 id="仅修改commit注释"><a href="#仅修改commit注释" class="headerlink" title="仅修改commit注释"></a>仅修改commit注释</h4><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> commit --amend</code></pre><p>此时会进入默认vim编辑器，修改注释完毕后保存就好了。</p><p>TODO: 解决git冲突</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ProtoBuf使用总结</title>
      <link href="/xyzhangblog/2020/10/17/bian-cheng-xiang-guan-ji-zhu/protobuf-shi-yong/protobuf-shi-yong/"/>
      <url>/xyzhangblog/2020/10/17/bian-cheng-xiang-guan-ji-zhu/protobuf-shi-yong/protobuf-shi-yong/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-序列化"><a href="#0x00-序列化" class="headerlink" title="0x00 序列化"></a>0x00 序列化</h2><p><strong>序列化是指将数据结构或者对象的状态转换成可存储（文件/内存）、可传输的格式</strong> 反之从存储或传输形式转换为数据结构或对象的形式成为反序列化</p><p>常见的序列化格式有：XML、JSON、YAML、plist…</p><h2 id="0x01-Protocol-Buffers简介"><a href="#0x01-Protocol-Buffers简介" class="headerlink" title="0x01 Protocol Buffers简介"></a>0x01 Protocol Buffers简介</h2><blockquote><p>ProtoBuf：google推出的语言中立，平台无关，可扩展的序列化数据的格式，可用于通信协议，数据存储等；相比XML更小巧、快速、简单。一旦定义要处理的数据的数据结构后，就可以利用ProtoBuf的代码生成工具生成相关代码。只需使用Protobuf对数据结构进行一次描述，就可以利用不同语言或从不同数据流中对结构化数据进行读写。</p></blockquote><p>Protocol buffers适合做数据存储或RPC数据交换格式。可用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化结构数据格式。Protocol buffers包含序列化格式的定义、对应语言的库和IDL编译器，正常情况下需要定义proto文件，然后使用IDL编译器编译成需要的语言。</p><p><strong>protocol buffers 诞生之初是为了解决服务器端新旧协议(高低版本)兼容性问题，名字也很体贴，“协议缓冲区”。只不过后期慢慢发展成用于传输数据</strong>。</p><h2 id="0x02-Protocol-Buffers的特点及用法"><a href="#0x02-Protocol-Buffers的特点及用法" class="headerlink" title="0x02 Protocol Buffers的特点及用法"></a>0x02 Protocol Buffers的特点及用法</h2><h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><ul><li>便捷引入新字段，且无需了解所有字段服务器即可进行数据的解析和传递</li><li>数据格式更具自我描述性</li><li>序列化与反序列化代码可以自动生成，避免手动解析</li></ul><h3 id="用法："><a href="#用法：" class="headerlink" title="用法："></a>用法：</h3><p>proto中所有结构化数据都被称为<code>message</code></p><pre class=" language-proto"><code class="language-proto">syntax = "proto3";message SearchRequest {  string query = 1;  int32 page_number = 2;  int32 result_per_page = 3;}</code></pre><h3 id="1-分配字段编号"><a href="#1-分配字段编号" class="headerlink" title="1. 分配字段编号"></a>1. 分配字段编号</h3><p>每个消息定义中的每个字段都有<strong>唯一的编号</strong>。这些字段编号用于标识消息二进制格式中的字段，并且在使用消息类型后不应更改。请注意，范围 1 到 15 中的字段编号需要一个字节进行编码，包括字段编号和字段类型。范围 16 至 2047 中的字段编号需要两个字节。所以你应该保留数字 1 到 15 作为非常频繁出现的消息元素。请记住为将来可能添加的频繁出现的元素留出一些空间。</p><p>可以指定的最小字段编号为1，最大字段编号为2^29^-1 或 536,870,911。也不能使用数字 19000 到 19999（FieldDescriptor :: kFirstReservedNumber 到 FieldDescriptor :: kLastReservedNumber），因为它们是为 Protocol Buffers实现保留的。</p><p>如果在 .proto 中使用这些保留数字中的一个，Protocol Buffers 编译的时候会报错。</p><p>同样，您不能使用任何以前 Protocol Buffers 保留的一些字段号码。保留字段是什么，下一节详细说明。</p><h3 id="2-保留字段"><a href="#2-保留字段" class="headerlink" title="2. 保留字段"></a>2. 保留字段</h3><p>如果您通过完全删除某个字段或将其注释掉来更新消息类型，那么未来的用户可以在对该类型进行自己的更新时重新使用该字段号。如果稍后加载到了的旧版本 <code>.proto</code> 文件，则会导致服务器出现严重问题，例如数据混乱，隐私错误等等。确保这种情况不会发生的一种方法是指定删除字段的字段编号（或名称，这也可能会导致 JSON 序列化问题）为 <code>reserved</code>。如果将来的任何用户试图使用这些字段标识符，Protocol Buffers 编译器将会报错。</p><pre class=" language-proto"><code class="language-proto">message Foo {  reserved 2, 15, 9 to 11;  reserved "foo", "bar";}</code></pre><p><strong>注意，不能在同一个 <code>reserved</code> 语句中混合字段名称和字段编号</strong>。如有需要需要像上面这个例子这样写。</p><h3 id="3-默认字段规则"><a href="#3-默认字段规则" class="headerlink" title="3. 默认字段规则"></a>3. 默认字段规则</h3><ul><li>字段名不能重复，必须唯一。</li><li>repeated 字段：可以在一个 message 中重复任何数字多次(包括 0 )，不过这些重复值的顺序被保留。</li></ul><h2 id="0x03-Protocol-Buffers的优缺点"><a href="#0x03-Protocol-Buffers的优缺点" class="headerlink" title="0x03 Protocol Buffers的优缺点"></a>0x03 Protocol Buffers的优缺点</h2><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ul><li>简单</li><li>数据体积小</li><li>反序列化速度快</li><li>自动化生成易于编码方式使用的数据访问类</li></ul><h4 id="举个例子："><a href="#举个例子：" class="headerlink" title="举个例子："></a>举个例子：</h4><p>如果要编码一个用户的名字和 email 信息，用 XML 的方式如下：</p><pre class=" language-xml"><code class="language-xml">  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>person</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>John Doe<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>email</span><span class="token punctuation">></span></span>jdoe@example.com<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>email</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>person</span><span class="token punctuation">></span></span></code></pre><p>相同需求，如果换成 protocol buffers 来实现，定义文件如下：</p><pre class=" language-c"><code class="language-c"><span class="token macro property"># Textual representation of a protocol buffer.</span><span class="token macro property"># This is *not* the binary format used on the wire.</span>person <span class="token punctuation">{</span>  name<span class="token punctuation">:</span> <span class="token string">"John Doe"</span>  email<span class="token punctuation">:</span> <span class="token string">"jdoe@example.com"</span><span class="token punctuation">}</span></code></pre><p>protocol buffers 通过编码以后，以二进制的方式进行数据传输，最多只需要 28 bytes 空间和 100-200 ns 的反序列化时间。但是 XML 则至少需要 69 bytes 空间（经过压缩以后，去掉所有空格）和 5000-10000 的反序列化时间。</p><p>上面说的是性能方面的优势。接下来说说编码方面的优势。</p><p>protocol buffers 自带代码生成工具，可以生成友好的数据访问存储接口。从而开发人员使用它来编码更加方便。例如上面的例子，如果用 C++ 的方式去读取用户的名字和 email，直接调用对应的 get 方法即可（所有属性的 get 和 set 方法的代码都自动生成好了，只需要调用即可）</p><pre class=" language-c"><code class="language-c">  cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Name: "</span> <span class="token operator">&lt;&lt;</span> person<span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>  cout <span class="token operator">&lt;&lt;</span> <span class="token string">"E-mail: "</span> <span class="token operator">&lt;&lt;</span> person<span class="token punctuation">.</span><span class="token function">email</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></code></pre><p>而 XML 读取数据会麻烦一些：</p><pre class=" language-xml"><code class="language-xml">  cout &lt;&lt; "Name: "       &lt;&lt; person.getElementsByTagName("name")->item(0)->innerText()       &lt;&lt; endl;  cout &lt;&lt; "E-mail: "       &lt;&lt; person.getElementsByTagName("email")->item(0)->innerText()       &lt;&lt; endl;</code></pre><p>Protobuf 语义更清晰，无需类似 XML 解析器的东西（因为 Protobuf 编译器会将 .proto 文件编译生成对应的数据访问类以对 Protobuf 数据进行序列化、反序列化操作）。</p><p>使用 Protobuf 无需学习复杂的文档对象模型，Protobuf 的编程模式比较友好，简单易学，同时它拥有良好的文档和示例，对于喜欢简单事物的人们而言，Protobuf 比其他的技术更加有吸引力。</p><p>protocol buffers 最后一个非常棒的特性是，即“向后”兼容性好，人们不必破坏已部署的、依靠“老”数据格式的程序就可以对数据结构进行升级。这样您的程序就可以不必担心因为消息结构的改变而造成的大规模的代码重构或者迁移的问题。因为添加新的消息中的 field 并不会引起已经发布的程序的任何改变(因为存储方式本来就是无序的，k-v 形式)。</p><p>当然 protocol buffers 也并不是完美的，在使用上存在一些局限性。</p><p>由于文本并不适合用来描述数据结构，所以 Protobuf 也不适合用来对基于文本的标记文档（如 HTML）建模。另外，由于 XML 具有某种程度上的自解释性，它可以被人直接读取编辑，在这一点上 Protobuf 不行，它以二进制的方式存储，除非你有 <code>.proto</code> 定义，否则你没法直接读出 Protobuf 的任何内容。</p><h2 id="0x04-参考资料："><a href="#0x04-参考资料：" class="headerlink" title="0x04 参考资料："></a>0x04 参考资料：</h2><p>pb的编码原理、更详细的用法分析：<a href="https://halfrost.com/protobuf_encode/">https://halfrost.com/protobuf_encode/</a></p><p>pb的性能分析参考：<a href="https://halfrost.com/protobuf_decode/#toc-13">https://halfrost.com/protobuf_decode/#toc-13</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> ProtoBuf </tag>
            
            <tag> 序列化 </tag>
            
            <tag> 反序列化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32+TencentOSTiny实现甲醛传感器</title>
      <link href="/xyzhangblog/2020/10/01/iot/tencentostiny-jia-quan-chuan-gan-qi/tencentostiny-ti-yan/"/>
      <url>/xyzhangblog/2020/10/01/iot/tencentostiny-jia-quan-chuan-gan-qi/tencentostiny-ti-yan/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-环境说明"><a href="#0x00-环境说明" class="headerlink" title="0x00. 环境说明"></a>0x00. 环境说明</h2><ul><li>软件环境：win10 64位 + MDK</li><li>开发板：TOS_EVB_G0开发板 x 1</li><li>传感器：英国 Dart 甲醛传感器 x 1</li><li>扩展板：E53甲醛传感器底板 x 1</li><li>下载器：ST-Link下载器 x 1</li></ul><h2 id="0x01-安装基础工具（硬件）"><a href="#0x01-安装基础工具（硬件）" class="headerlink" title="0x01. 安装基础工具（硬件）"></a>0x01. 安装基础工具（硬件）</h2><h4 id="连接ST-Link与开发板，严格按照如下方式进行连接否则可能烧坏MCU"><a href="#连接ST-Link与开发板，严格按照如下方式进行连接否则可能烧坏MCU" class="headerlink" title="连接ST-Link与开发板，严格按照如下方式进行连接否则可能烧坏MCU"></a>连接ST-Link与开发板，严格按照如下方式进行连接否则可能烧坏MCU</h4><p>开发板3v3—&gt; STlink 3.3V<br>开发板DIO—&gt; STlink SWDIO<br>开发板CLK—&gt; STlink SWCLK<br>开发板GND—&gt; STlink GND</p><h4 id="设置跳线帽，切换boot选择端子和串口选择端子"><a href="#设置跳线帽，切换boot选择端子和串口选择端子" class="headerlink" title="设置跳线帽，切换boot选择端子和串口选择端子"></a>设置跳线帽，切换boot选择端子和串口选择端子</h4><ol><li>开发版上的ESP固件下载配置切换到GND，使wifi处于下载模式</li><li>Boot选择切换到0</li><li>串口切换端子置于中间，使ESP8266直接与PC串口连接</li></ol><p>设置完成后的结果如下图所示：</p><img src="/xyzhangblog/2020/10/01/iot/tencentostiny-jia-quan-chuan-gan-qi/tencentostiny-ti-yan/%E7%AB%AF%E5%AD%90%E8%AE%BE%E7%BD%AE.jpg" class="" title="端子设置"><h2 id="0x02-安装基础工具（软件）"><a href="#0x02-安装基础工具（软件）" class="headerlink" title="0x02. 安装基础工具（软件）"></a>0x02. 安装基础工具（软件）</h2><h4 id="安装MDK软件"><a href="#安装MDK软件" class="headerlink" title="安装MDK软件"></a>安装MDK软件</h4><ul><li><p>激活软件，导入License，注意这部需要以管理员身份运行</p></li><li><p>安装单片机型号中对应的Pack</p><p>可以直接在MDK软件上在线安装，在导航栏打开Pack安装页面，找到STM32G0xx，点击install安装</p><img src="/xyzhangblog/2020/10/01/iot/tencentostiny-jia-quan-chuan-gan-qi/tencentostiny-ti-yan/image-20201001164941942.png" class="" title="image-20201001164941942"></li></ul><h4 id="安装ST-Link驱动"><a href="#安装ST-Link驱动" class="headerlink" title="安装ST-Link驱动"></a>安装ST-Link驱动</h4><p>前往ST官网即可下载：</p><p><a href="https://www.st.com/content/st_com/zh/products/development-tools/software-development-tools/stm32-software-development-tools/stm32-utilities/stsw-link009.html">https://www.st.com/content/st_com/zh/products/development-tools/software-development-tools/stm32-software-development-tools/stm32-utilities/stsw-link009.html</a></p><p>安装完成后打开设备管理器，查看通用串行总线设备，出现如下所示，则驱动安装成功</p><img src="/xyzhangblog/2020/10/01/iot/tencentostiny-jia-quan-chuan-gan-qi/tencentostiny-ti-yan/image-20201001165811036.png" class="" title="image-20201001165811036"><h4 id="CH340串口驱动安装"><a href="#CH340串口驱动安装" class="headerlink" title="CH340串口驱动安装"></a>CH340串口驱动安装</h4><p>直接通过互联网搜索CH340串口芯片的驱动进行下载安装即可</p><img src="/xyzhangblog/2020/10/01/iot/tencentostiny-jia-quan-chuan-gan-qi/tencentostiny-ti-yan/image-20201001163019855.png" class="" title="image-20201001163019855"><h4 id="安装串口调试助手"><a href="#安装串口调试助手" class="headerlink" title="安装串口调试助手"></a>安装串口调试助手</h4><p>工具下载：<a href="http://www.daxia.com/download/sscom.rar">http://www.daxia.com/download/sscom.rar</a></p><img src="/xyzhangblog/2020/10/01/iot/tencentostiny-jia-quan-chuan-gan-qi/tencentostiny-ti-yan/image-20201001164049729.png" class="" title="image-20201001164049729"><p>根据PC和终端之间的连接选择正确的串行端口。</p><p>打开设备管理器，在端口列表（如果没有端口选项需要在“查看”中选取“显示隐藏的设备”）中可以看到连接所使用的端口号</p><p><del>这里遇到一个非常蠢的问题：STLink和USB需要同时连接到板子上，否则就会出现电脑不识别CH340设备的现象</del></p><img src="/xyzhangblog/2020/10/01/iot/tencentostiny-jia-quan-chuan-gan-qi/tencentostiny-ti-yan/image-20201001172758481.png" class="" title="image-20201001172758481"><h2 id="0x03-烧写腾讯云定制固件"><a href="#0x03-烧写腾讯云定制固件" class="headerlink" title="0x03. 烧写腾讯云定制固件"></a>0x03. 烧写腾讯云定制固件</h2><h4 id="下载固件"><a href="#下载固件" class="headerlink" title="下载固件"></a>下载固件</h4><p>下载链接：<a href="https://github.com/tencentyun/qcloud-iot-esp-wifi">https://github.com/tencentyun/qcloud-iot-esp-wifi</a> 、</p><p>使用git下载的命令如下：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> clone https://github.com/tencentyun/qcloud-iot-esp-wifi.git</code></pre><h4 id="下载烧写工具"><a href="#下载烧写工具" class="headerlink" title="下载烧写工具"></a>下载烧写工具</h4><p>前往乐鑫官网下载Flash下载工具：</p><p><a href="https://www.espressif.com/zh-hans/support/download/other-tools">https://www.espressif.com/zh-hans/support/download/other-tools</a></p><h4 id="固件说明"><a href="#固件说明" class="headerlink" title="固件说明"></a>固件说明</h4><p>腾讯云IoT定制的AT模组固件QCloud_IoT_AT_ESP8266，适用于所有FLASH大小为2MB或者2MB以上的 ESP8266模组。 </p><p>AT串口使用UART0，默认的Tx为GPIO1，Rx为GPIO3。但因为ESP8266的UART0 默认会在上电启动期 间输出一些打印，如果打印信息影响设备功能，可在上电期间将 U0TXD(GPIO1)、U0RXD(GPIO3) 分别 与 U0RTS (GPIO15)，U0CTS(GPIO13)进行交换，以屏蔽打印。因此提供两个版本的固件：</p><ul><li>名称包含UART_1_3的固件串口使用的Tx为GPIO1，Rx为GPIO3。 </li><li>名称包含UART_15_13的固件串口使用的Tx为GPIO15，Rx为GPIO13。 </li></ul><p>进入QCloud_IoT_AT_ESP8266_FW，本文中我们使用第一个固件</p><h4 id="烧写固件"><a href="#烧写固件" class="headerlink" title="烧写固件"></a>烧写固件</h4><h5 id="运行下载的乐鑫Flash烧写工具"><a href="#运行下载的乐鑫Flash烧写工具" class="headerlink" title="运行下载的乐鑫Flash烧写工具"></a>运行下载的乐鑫Flash烧写工具</h5><ol><li><p>选择Develop Mode</p></li><li><p>选择ESP8266下载工具</p><img src="/xyzhangblog/2020/10/01/iot/tencentostiny-jia-quan-chuan-gan-qi/tencentostiny-ti-yan/image-20201001175540012.png" class="" title="image-20201001175540012"><p>按照上图设置进行配置点击Start后等待下载完成</p></li><li><p>下载完成</p><img src="/xyzhangblog/2020/10/01/iot/tencentostiny-jia-quan-chuan-gan-qi/tencentostiny-ti-yan/image-20201001175803789.png" class="" title="image-20201001175803789"><p>完成后即可关闭工具，<strong>将串口选择端子恢复到默认状态</strong></p></li></ol><h2 id="0x04-接入腾讯云IoT"><a href="#0x04-接入腾讯云IoT" class="headerlink" title="0x04. 接入腾讯云IoT"></a>0x04. 接入腾讯云IoT</h2><h3 id="云端操作"><a href="#云端操作" class="headerlink" title="云端操作"></a>云端操作</h3><h4 id="新建项目及产品"><a href="#新建项目及产品" class="headerlink" title="新建项目及产品"></a>新建项目及产品</h4><p>项目及产品创建时保留默认选项即可</p><h4 id="数据模板"><a href="#数据模板" class="headerlink" title="数据模板"></a>数据模板</h4><p>产品界面点击“数据模板”，点击“导入json”，导入如下的json代码</p><pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span>  <span class="token property">"version"</span><span class="token operator">:</span> <span class="token string">"1.0"</span><span class="token punctuation">,</span>  <span class="token property">"profile"</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token property">"ProductId"</span><span class="token operator">:</span> <span class="token string">"BDDSF87WEA"</span><span class="token punctuation">,</span>    <span class="token property">"CategoryId"</span><span class="token operator">:</span> <span class="token string">"1"</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token property">"properties"</span><span class="token operator">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">{</span>      <span class="token property">"id"</span><span class="token operator">:</span> <span class="token string">"ch20_ppm_value"</span><span class="token punctuation">,</span>      <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"甲醛浓度值"</span><span class="token punctuation">,</span>      <span class="token property">"desc"</span><span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">,</span>      <span class="token property">"mode"</span><span class="token operator">:</span> <span class="token string">"r"</span><span class="token punctuation">,</span>      <span class="token property">"define"</span><span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"float"</span><span class="token punctuation">,</span>        <span class="token property">"min"</span><span class="token operator">:</span> <span class="token string">"0"</span><span class="token punctuation">,</span>        <span class="token property">"max"</span><span class="token operator">:</span> <span class="token string">"2"</span><span class="token punctuation">,</span>        <span class="token property">"start"</span><span class="token operator">:</span> <span class="token string">"0"</span><span class="token punctuation">,</span>        <span class="token property">"step"</span><span class="token operator">:</span> <span class="token string">"0.001"</span><span class="token punctuation">,</span>        <span class="token property">"unit"</span><span class="token operator">:</span> <span class="token string">"ppm(mg/m3)"</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      <span class="token property">"required"</span><span class="token operator">:</span> <span class="token boolean">false</span>    <span class="token punctuation">}</span>  <span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token property">"events"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token property">"actions"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre><h4 id="创建设备"><a href="#创建设备" class="headerlink" title="创建设备"></a>创建设备</h4><p>点击“设备调试”，进入后点击“新建设备”，创建成功后进入设备可以看到产品ID、设备名称、设备密钥等相关信息；</p><h3 id="传感器端操作"><a href="#传感器端操作" class="headerlink" title="传感器端操作"></a>传感器端操作</h3><p>进入 &lt; TencentOS-tiny\board\TencentOS_tiny_EVB_G0\KEIL\mqtt_iot_explorer_tc_ch20_oled&gt; 目录，打开TencentOS_tiny.uvprojx工程。</p><h4 id="修改Wifi接入信息"><a href="#修改Wifi接入信息" class="headerlink" title="修改Wifi接入信息"></a>修改Wifi接入信息</h4><p>编辑<code>mqtt_iot_explorer_tc_ch20_oled.c</code>文件，修改<code>esp8266_tencent_firmware_join_ap</code>函数中的要接入的WiFi名称和密码</p><img src="/xyzhangblog/2020/10/01/iot/tencentostiny-jia-quan-chuan-gan-qi/tencentostiny-ti-yan/image-20201001200336241.png" class="" title="image-20201001200336241"><h4 id="修改云端对接信息"><a href="#修改云端对接信息" class="headerlink" title="修改云端对接信息"></a>修改云端对接信息</h4><p>修改文件中的宏定义，对应腾讯云中的配置信息</p><img src="/xyzhangblog/2020/10/01/iot/tencentostiny-jia-quan-chuan-gan-qi/tencentostiny-ti-yan/image-20201001200710678.png" class="" title="image-20201001200710678"><p><del><strong>此处可自行发挥修改程序代码，实现更加复杂有趣的功能</strong></del></p><h4 id="编译下载"><a href="#编译下载" class="headerlink" title="编译下载"></a>编译下载</h4><p>编译完成-&gt;进入工程配置界面-&gt;选择debug选项-&gt;选择ST-Link Debugger-&gt;点击settings 该页面中的Unit选择ST-Link/V2，Port选择SW，点击确认保存配置；</p><img src="/xyzhangblog/2020/10/01/iot/tencentostiny-jia-quan-chuan-gan-qi/tencentostiny-ti-yan/@9ZW3%60FJ%60Z9RJ9%60LLK7AO8A.png" class="" title="img"><p>回到主界面点击下载；</p><h4 id="使用串口助手查看日志"><a href="#使用串口助手查看日志" class="headerlink" title="使用串口助手查看日志"></a>使用串口助手查看日志</h4><p>打开串口助手后，点击打开串口，点击开发板上的reset按钮，程序开始运行，可在主界面中查看运行日志</p><p>WiFi连接成功</p><img src="/xyzhangblog/2020/10/01/iot/tencentostiny-jia-quan-chuan-gan-qi/tencentostiny-ti-yan/U1%5B2$YTXDK@T0G@VTI01PSP.png" class="" title="img"><p>接入云平台成功</p><img src="/xyzhangblog/2020/10/01/iot/tencentostiny-jia-quan-chuan-gan-qi/tencentostiny-ti-yan/image-20201001204024547.png" class="" title="image-20201001204024547"><p>上述步骤完成后即可回到腾讯云界面查看数据上报情况</p><h2 id="0x05-成品展示"><a href="#0x05-成品展示" class="headerlink" title="0x05. 成品展示"></a>0x05. 成品展示</h2><ul><li>开发板</li></ul><img src="/xyzhangblog/2020/10/01/iot/tencentostiny-jia-quan-chuan-gan-qi/tencentostiny-ti-yan/image-20201001215542720.png" class="" title="image-20201001215542720"><ul><li>腾讯云数据展示界面</li></ul><img src="/xyzhangblog/2020/10/01/iot/tencentostiny-jia-quan-chuan-gan-qi/tencentostiny-ti-yan/image-20201001215415580.png" class="" title="image-20201001215415580"><ul><li>腾讯连连小程序数据展示界面</li></ul><img src="/xyzhangblog/2020/10/01/iot/tencentostiny-jia-quan-chuan-gan-qi/tencentostiny-ti-yan/image-20201001215931807.png" class="" title="image-20201001215931807"><ul><li>腾讯连连公众号数据报警界面</li></ul><img src="/xyzhangblog/2020/10/01/iot/tencentostiny-jia-quan-chuan-gan-qi/tencentostiny-ti-yan/image-20201001215758591.png" class="" title="image-20201001215758591"><h2 id="0x06-后记"><a href="#0x06-后记" class="headerlink" title="0x06. 后记"></a>0x06. 后记</h2><p>感谢 @supowang 大佬提供的极其详细的<a href="http://mk.oa.com/note/817">教程</a>，本文中大部分内容来自于其所写的教程步骤，另外添加了少部分自己在实践过程中的踩坑记录，后续有时间会尝试接入其他传感器完成更复杂更好玩的实践。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> IoT </tag>
            
            <tag> TencentOS-Tiny </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Block使用总结</title>
      <link href="/xyzhangblog/2020/09/24/ios-kai-fa/block-shi-yong-zong-jie/block-shi-yong-zong-jie/"/>
      <url>/xyzhangblog/2020/09/24/ios-kai-fa/block-shi-yong-zong-jie/block-shi-yong-zong-jie/</url>
      
        <content type="html"><![CDATA[<h3 id="Block应用场景"><a href="#Block应用场景" class="headerlink" title="Block应用场景"></a>Block应用场景</h3><ol><li><p>响应事件</p><blockquote><p>需求：UIViewController中使用UICollectionView构造集合视图，在集合视图中自定义Cell，每个Cell中有一个按钮，需要监听该按钮并对其做出相应</p></blockquote><p>在CellView中声明Block类型的属性，在按钮点击事件中调用该block</p><pre class=" language-objective-c"><code class="language-objective-c">//按钮点击Block@property (nonatomic, copy) void (^btnClickedBlock)(void);// 激活事件#pragma mark - 按钮点击事件- (IBAction)btnClickedAction:(UIButton *)sender {    if (self.btnClickedBlock) {        self.btnClickedBlock();    }}</code></pre><p>在ViewController中调用UICollectionView生成cell的代理方法<code>- (UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath</code>时，使用setter方法设置CellView中的block属性，其中包含按钮点击后执行的逻辑。—可以不在定义CellView时确定其执行逻辑，而是通过外部的setter方法确定</p><pre class=" language-objective-c"><code class="language-objective-c">// 设置cell 响应事件cell.btnClickedBlock = ^(UIButton *sender) {    // 执行逻辑};</code></pre></li><li><p>传递数据</p><blockquote><p>在UICollectionView中获取选中Cell的序号，根据选中的Cell执行不同逻辑</p></blockquote><pre class=" language-objective-c"><code class="language-objective-c">@property (strong, nonatomic) void (^handleDidSelectedItem)(int indexPath);- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath{    [tableView deselectRowAtIndexPath:indexPath animated:YES];    _handleDidSelectedItem ? _handleDidSelectedItem(indexPath) : NULL;}</code></pre></li></ol><h3 id="Block使用注意事项"><a href="#Block使用注意事项" class="headerlink" title="Block使用注意事项"></a>Block使用注意事项</h3><ol><li><p>局部变量与__block修饰符</p><p>block会在所在函数中捕获局部变量，但无法修改局部变量，可以修改全局变量、静态变量。</p><ul><li>不能修改局部变量：block捕获的是局部变量的const值，只是名字一样无法修改，如果想修改局部变量可以在定义时使用__block修饰。</li><li>可以修改静态变量：静态变量属于类，可以在block中调用</li></ul></li><li><p>循环引用问题</p><p>Self持有Block对象, 同时在Block内部又调用了Self, 导致了Self持有Block, Block又持有Self，那就会引起循环引用</p><ul><li><p>TestCycleRetain.m</p><pre class=" language-objective-c"><code class="language-objective-c">- (void) dealloc {    NSLog(@"no cycle retain");} - (id) init {    self = [super init];    if (self) {        #if TestCycleRetainCase1        //会循环引用        self.myblock = ^{            [self doSomething];        };        #endif NSLog(@"myblock is %@", self.myblock);    }    return self;} </code></pre></li></ul><p>循环引用的避免：声明一个self的弱指针，在block中引用该弱指针</p><pre class=" language-objective-c"><code class="language-objective-c">                #elif TestCycleRetainCase3        //不会循环引用        __weak TestCycleRetain * weakSelf = self;        self.myblock = ^{            [weakSelf doSomething];        };</code></pre><p>上述使用block中存在一个隐患，不知道self什么时候会被释放，为了保证在block中不会被释放，需要配合strong来使用</p><pre class=" language-objective-c"><code class="language-objective-c">__weak __typeof(self) weakSelf = self; self.testBlock =  ^{    __strong __typeof(weakSelf) strongSelf = weakSelf;       [strongSelf test]; });</code></pre><blockquote><p>From: Raven</p><p>以上操作带来一个疑问:<strong>通过弱引用接触循环引用的Self, 如果在Block内部再强引用, 岂不是又循环引用了吗?到底是如何延长Self的生命周期的?</strong></p><p><strong>解答</strong>:</p><p>block被赋值到<code>self</code>的成员变量时, arc下系统会将该block从栈区拷贝到堆区, 此时block会捕获它所用到的变量使用<code>__weak</code>可以保证block和<code>self</code>之间不会发生循环引用, 而在Block的代码块内声明<code>_ _strong</code>指针, 将会对self产生一个强引用延迟self的释放, 但和直接使用<code>self</code>所不同的是, <strong>在Block内声明的指针会在Block的作用域外销毁</strong>, 因此这个循环引用只会持续到block执行完毕为止, 当block执行完毕, strongSelf被销毁, <code>self</code>不再被Block所持有, 就可以顺利释放了.</p></blockquote></li></ol><ol start="3"><li><p>并不是所有Block里面的self都需要weak</p><ul><li><p>调用系统方法：</p><pre class=" language-objective-c"><code class="language-objective-c">[UIView animateWithDuration:0.5 animations:^{        NSLog(@"%@", self);}];</code></pre><p>这个block本身存在于静态方法中，虽然block对self强引用，但self不持有该静态方法，所以完全可以在block内部使用self</p></li></ul></li></ol><h3 id="block与内存管理"><a href="#block与内存管理" class="headerlink" title="block与内存管理"></a>block与内存管理</h3><p>根据Block在内存中的位置分为三种类型：</p><ul><li>NSGlobalBlock：全局区block，设置在程序的数据区域中</li><li>NSStackBlock：栈区，超出变量作用域则栈上的Block和__block变量都被销毁</li><li>NSMallocBlock：堆区，在变量作用域结束时不受影响</li></ul><ol><li><p>位于全局区：GlobalBlock</p><p>生成在全局区的block的情况：</p><ul><li><p>直接将block定义为全局变量</p><pre class=" language-objective-c"><code class="language-objective-c">void(^block)(void) = ^ { NSLog(@"Global Block");};int main() {}</code></pre></li></ul></li><li><p>位于栈内存：StackBlock –最常见的block</p><pre class=" language-objective-c"><code class="language-objective-c">NSInteger i = 10; block = ^{      NSLog(@"%ld", i); };block;</code></pre></li><li><p>位于堆内存：MallocBlock</p><p>堆中block无法直接创建，需要执行copy后才能放入堆中</p></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Block </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
