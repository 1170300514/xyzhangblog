<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/xyzhangblog/2021/04/18/java/springmvc-jiao-cheng/springmvc-jiao-cheng/"/>
      <url>/xyzhangblog/2021/04/18/java/springmvc-jiao-cheng/springmvc-jiao-cheng/</url>
      
        <content type="html"><![CDATA[<h2 id="SpringMVC教程"><a href="#SpringMVC教程" class="headerlink" title="SpringMVC教程"></a>SpringMVC教程</h2><h3 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h3><p>MVC是模型(Model) : dao,service、视图(View) : jsp、控制器(Controller) : serlvet的简写，是一种软件设计规范。MVC主要作用是<strong>降低了视图与业务逻辑间的双向偶合</strong>。</p><p><strong>Model（模型）：</strong>数据模型，提供要展示的数据，因此包含数据和行为，可以认为是领域模型或JavaBean组件（包含数据和行为），不过现在一般都分离开来：Value Object（数据Dao） 和 服务层（行为Service）。也就是模型提供了模型数据查询和模型数据的状态更新等功能，包括数据和业务。</p><p><strong>View（视图）：</strong>负责进行模型的展示，一般就是我们见到的用户界面，客户想看到的东西。</p><p><strong>Controller（控制器）：</strong>接收用户请求，委托给模型进行处理（状态改变），处理完毕后把返回的模型数据返回给视图，由视图负责展示。 也就是说控制器做了个调度员的工作。</p><p><strong>最典型的MVC就是JSP + servlet + javabean的模式。</strong></p><p><strong>MVC框架要做哪些事情</strong></p><ol><li>将url映射到java类或java类的方法 .</li><li>封装用户提交的数据 .</li><li>处理请求–调用相关的业务处理–封装响应数据 .</li><li>将响应的数据进行渲染 . jsp / html 等表示层数据 .</li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/xyzhangblog/2021/04/18/java/mybatis-jiao-cheng/mybatis-jiao-cheng/"/>
      <url>/xyzhangblog/2021/04/18/java/mybatis-jiao-cheng/mybatis-jiao-cheng/</url>
      
        <content type="html"><![CDATA[<h2 id="MyBatis教程"><a href="#MyBatis教程" class="headerlink" title="MyBatis教程"></a>MyBatis教程</h2><p>官方教程 <a href="https://mybatis.org/mybatis-3/zh/getting-started.html">https://mybatis.org/mybatis-3/zh/getting-started.html</a></p><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h3><p>​    MyBatis 是一款优秀的<strong>持久层框架</strong>，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集（RestSet）。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Ordinary Java Object,普通的 Java对象)映射成数据库中的记录。</p><h4 id="1-1-持久层"><a href="#1-1-持久层" class="headerlink" title="1.1 持久层"></a>1.1 持久层</h4><ul><li><p>完成持久化工作的代码</p></li><li><p>数据持久化：将数据在持久状态与瞬时状态转化的过程。</p><p>使用MyBatis原因：简化JDBC代码，解除sql与程序代码的耦合提高可维护性，支持动态sql</p></li></ul><h3 id="2-使用"><a href="#2-使用" class="headerlink" title="2. 使用"></a>2. 使用</h3><h4 id="2-1-配置文件"><a href="#2-1-配置文件" class="headerlink" title="2.1 配置文件"></a>2.1 配置文件</h4><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!--核心配置文件--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>environments</span> <span class="token attr-name">default</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>development<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!--可以创建多个数据库环境 用environment进行包裹 进行默认选择 此处默认选择development环境--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>environment</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>development<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>transactionManager</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>JDBC<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dataSource</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>POOLED<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                <span class="token comment" spellcheck="true">&lt;!--mysql驱动--></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>driver<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.mysql.cj.jdbc.Driver<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>                <span class="token comment" spellcheck="true">&lt;!--url连接数据库 通过右侧的database选项进行数据库连接--></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>url<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>jdbc:mysql://localhost:3306/mybatis?useSSL<span class="token punctuation">=</span>true&amp;amp;serverTimezone<span class="token punctuation">=</span>UTC<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>username<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>root<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>password<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>123456<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dataSource</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>environment</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>environments</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mappers</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mapper</span> <span class="token attr-name">resource</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>org/mybatis/example/BlogMapper.xml<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mappers</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">></span></span></code></pre><h4 id="2-2-从XML中构建SqlSessionFactory获取-SqlSession"><a href="#2-2-从XML中构建SqlSessionFactory获取-SqlSession" class="headerlink" title="2.2 从XML中构建SqlSessionFactory获取 SqlSession"></a>2.2 从XML中构建SqlSessionFactory获取 SqlSession</h4><blockquote><p>每个基于 MyBatis 的应用都是以一个 SqlSessionFactory 的实例为核心的。SqlSessionFactory 的实例可以通过 SqlSessionFactoryBuilder 获得。而 SqlSessionFactoryBuilder 则可以从 XML 配置文件或一个预先定制的 Configuration 的实例构建出 SqlSessionFactory 的实例。</p></blockquote><p>从建造者模式的builder创建出factory</p><p>获取sqlsessionfactory对象</p><pre class=" language-java"><code class="language-java">        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//获取配置文件</span>            String resource <span class="token operator">=</span> <span class="token string">"org/mybatis/example/mybatis-config.xml"</span><span class="token punctuation">;</span>            InputStream inputStream <span class="token operator">=</span> Resources<span class="token punctuation">.</span><span class="token function">getResourceAsStream</span><span class="token punctuation">(</span>resource<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//加载流构建工厂</span>            SqlSessionFactory sqlSessionFactory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SqlSessionFactoryBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span>inputStream<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span></code></pre><ul><li>获取到SqlSessionFactory对象后，我们就可以从中获取 SqlSession 的实例。SqlSession完全包含了面向数据库执行SQL命令所需的所有方法，通过该实例就可以直接执行已映射的SQL语句。</li></ul><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">static</span> SqlSession <span class="token function">getSqlSession</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> sqlSessionFactory<span class="token punctuation">.</span><span class="token function">openSession</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><ul><li><p>从数据库中获取想要的数据有两种方式：</p><ul><li><p><strong>（推荐使用）</strong>使用正确描述每个语句的参数和返回值的接口（比如 UserDao.class），不仅可以执行清晰和类型安全的代码，而且还不用进行强制类型转换。</p><pre class=" language-java"><code class="language-java">UserDao mapper <span class="token operator">=</span> sqlSession<span class="token punctuation">.</span><span class="token function">getMapper</span><span class="token punctuation">(</span>UserDao<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>List<span class="token operator">&lt;</span>User<span class="token operator">></span> userList <span class="token operator">=</span> mapper<span class="token punctuation">.</span><span class="token function">getUserList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li><li><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//需要进行强制类型转换 不推荐</span>List<span class="token operator">&lt;</span>User<span class="token operator">></span> userList <span class="token operator">=</span> sqlSession<span class="token punctuation">.</span><span class="token function">selectList</span><span class="token punctuation">(</span><span class="token string">"com.xyzhang.dao.UserDao.getUserList"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li></ul></li></ul><h4 id="2-3-执行流程解析"><a href="#2-3-执行流程解析" class="headerlink" title="2.3 执行流程解析"></a>2.3 执行流程解析</h4><p>MyBatis 提供的全部特性都可以利用基于 XML 的映射语言来实现，下文的例子可满足以上对SqlSession的调用</p><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8" ?></span><span class="token doctype">&lt;!DOCTYPE mapper        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"        "http://mybatis.org/dtd/mybatis-3-mapper.dtd"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mapper</span> <span class="token attr-name">namespace</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.xyzhang.dao.UserDao<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!--select查询语句--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>getUserList<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.xyzhang.pojo.User<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        select * from mybatis.user    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mapper</span><span class="token punctuation">></span></span></code></pre><ol><li><p>在命名空间“com.xyzhang.dao.UserDao”中定义了一个名为“getUserList”的映射语句，这种命名允许使用指定的完全限定名“com.xyzhang.dao.UserDao.getUserList”来调用映射语句。<code>List&lt;User&gt; userList = sqlSession.selectList("com.xyzhang.dao.UserDao.getUserList");</code></p></li><li><p>该命名也可以直接映射到在命名空间中同名的 Mapper 类，并将已映射的 select 语句中的名字、参数和返回类型匹配成方法。</p><p><code>UserDao mapper = sqlSession.getMapper(UserDao.class); List&lt;User&gt; userList = mapper.getUserList();</code></p><ul><li>第二种方法有很多优势，首先它不依赖于字符串字面值，会更安全一点； 其次，如果你的 IDE 有代码补全功能，那么代码补全可以帮你快速选择已映射的 SQL 语句。</li></ul></li></ol><p><img src="Mybatis-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png" alt="Mybatis-执行流程"></p><h4 id="2-4-作用域和生命周期"><a href="#2-4-作用域和生命周期" class="headerlink" title="2.4 作用域和生命周期"></a>2.4 作用域和生命周期</h4><p><img src="Mybatis-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="Mybatis-生命周期"></p><p><strong>SqlSessionFactoryBuilder</strong>：</p><p>这个类可以被实例化、使用和丢弃，一旦创建了 SqlSessionFactory，就不再需要它了。 因此 SqlSessionFactoryBuilder 实例的最佳作用域是方法作用域（也就是<strong>局部方法变量</strong>）。 你可以重用 SqlSessionFactoryBuilder 来创建多个 SqlSessionFactory 实例，但是最好还是不要让其一直存在，以保证所有的 XML 解析资源可以被释放给更重要的事情。</p><p><strong>SqlSessionFactory：数据库连接池</strong></p><p>SqlSessionFactory 一旦被创建就应该在应用的运行期间<strong>一直存在</strong>，不应丢弃它或重新创建。 因此 SqlSessionFactory 的最佳作用域是应用作用域（全局变量）。 最简单的实现方式是<strong>使用单例模式或者静态单例模式</strong>。</p><p><strong>SqlSession：数据库连接池的一个请求</strong></p><p><strong>每个线程都应该有它自己的 SqlSession 实例</strong>。SqlSession 的实例<strong>不是线程安全</strong>的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域。 绝对不能将 SqlSession 实例的引用放在一个类的静态域，甚至一个类的实例变量也不行。 也绝不能将 SqlSession 实例的引用放在任何类型的托管作用域中，比如 Servlet 框架中的 HttpSession。</p><p>每次收到的 HTTP 请求，就可以打开一个 SqlSession，返回一个响应，就关闭它。</p><p>并且应该把关闭操作放到 finally 块中以确保每次都能执行关闭。</p><p><strong>映射器实例：</strong>（mapper）</p><p>映射器接口的实例是从 SqlSession 中获得的。因此从技术层面讲，任何映射器实例的最大作用域是和请求它们的 SqlSession 相同的。尽管如此，映射器实例的最佳作用域是方法作用域。 也就是说，映射器实例应该在调用它们的方法中被请求，用过之后即可丢弃。 </p><p>最好把映射器放在方法作用域内：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">try</span> <span class="token punctuation">(</span>SqlSession session <span class="token operator">=</span> sqlSessionFactory<span class="token punctuation">.</span><span class="token function">openSession</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  BlogMapper mapper <span class="token operator">=</span> session<span class="token punctuation">.</span><span class="token function">getMapper</span><span class="token punctuation">(</span>BlogMapper<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 你的应用逻辑代码</span><span class="token punctuation">}</span></code></pre><h4 id="2-5-日后使用方式"><a href="#2-5-日后使用方式" class="headerlink" title="2.5 日后使用方式"></a>2.5 日后使用方式</h4><p>只修改接口（UserMapper.java）和配置文件（resource文件下的UserMapper.xml）即可</p><h3 id="3-XML映射文件及注解"><a href="#3-XML映射文件及注解" class="headerlink" title="3. XML映射文件及注解"></a>3. XML映射文件及注解</h3><h4 id="3-0-注解："><a href="#3-0-注解：" class="headerlink" title="3.0 注解："></a>3.0 注解：</h4><ol><li><p>简化开发，直接在接口上实现添加注解；</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//查询全部用户</span><span class="token annotation punctuation">@Select</span><span class="token punctuation">(</span><span class="token string">"select id,name,pwd password from user"</span><span class="token punctuation">)</span><span class="token keyword">public</span> List<span class="token operator">&lt;</span>User<span class="token operator">></span> <span class="token function">getAllUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li><li><p>在核心配置文件上使用class绑定接口（不是配置文件），但可以与配置文件同时使用。</p><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!--使用class绑定接口--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mappers</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mapper</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.kuang.mapper.UserMapper<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mappers</span><span class="token punctuation">></span></span></code></pre></li></ol><p>实现机制：反射</p><p>底层：动态代理</p><p><strong>关于@Param() 注解：</strong></p><ul><li>在方法只接受一个参数的情况下，可以不使用@Param。</li><li>在方法接受多个参数的情况下，建议一定要使用@Param注解给参数命名。</li><li>如果参数是 对象类型， 则不能使用@Param。</li><li>不使用@Param注解时，参数只能有一个，并且是Javabean。</li></ul><h4 id="3-1-namespace"><a href="#3-1-namespace" class="headerlink" title="3.1 namespace"></a>3.1 namespace</h4><h4 id="3-2-select：选择，查询语句"><a href="#3-2-select：选择，查询语句" class="headerlink" title="3.2 select：选择，查询语句"></a>3.2 select：选择，查询语句</h4><ul><li>id：对应namespace中的方法名；</li><li>resultType：Sql语句执行的返回值；</li><li>parameterType：参数类型</li></ul><p>📌<strong>增删改需要提交事务sqlSession。commit()；</strong>也可在getSqlsession()时设置为自动提交事务（设置参数为true即可 看<strong>源码！！！</strong>）</p><pre class=" language-java"><code class="language-java">    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//通过实体类获取sqlSession实例</span>        SqlSession sqlSession <span class="token operator">=</span> MybatisUtils<span class="token punctuation">.</span><span class="token function">getSqlSession</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//获取映射实例</span>        UserMapper mapper <span class="token operator">=</span> sqlSession<span class="token punctuation">.</span><span class="token function">getMapper</span><span class="token punctuation">(</span>UserMapper<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        mapper<span class="token punctuation">.</span><span class="token function">addUser</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token string">"Num4"</span><span class="token punctuation">,</span><span class="token string">"147852"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//提交事务才能添加成功！！！</span>        sqlSession<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        sqlSession<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h4 id="3-3-Insert"><a href="#3-3-Insert" class="headerlink" title="3.3 Insert"></a>3.3 Insert</h4><h4 id="3-4-update"><a href="#3-4-update" class="headerlink" title="3.4 update"></a>3.4 update</h4><h4 id="3-5-delete"><a href="#3-5-delete" class="headerlink" title="3.5 delete"></a>3.5 delete</h4><ul><li>以上操作的通用顺序：</li></ul><ol><li>编写接口</li><li>编写对应mapper的sql语句</li><li>测试</li></ol><h4 id="3-6-map传递参数"><a href="#3-6-map传递参数" class="headerlink" title="3.6 map传递参数"></a>3.6 map传递参数</h4><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">//使用map进行数据插入</span>    <span class="token keyword">int</span> <span class="token function">addUser2</span><span class="token punctuation">(</span>Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span>Object<span class="token operator">></span> map<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><pre class=" language-xml"><code class="language-xml">    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>insert</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>addUser2<span class="token punctuation">"</span></span> <span class="token attr-name">parameterType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>map<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        insert into mybatis.user(id, name, pwd) values (#{id},#{name},#{pwd});    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>insert</span><span class="token punctuation">></span></span></code></pre><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">//测试使用map增加对象</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addUser2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        SqlSession sqlSession <span class="token operator">=</span> MybatisUtils<span class="token punctuation">.</span><span class="token function">getSqlSession</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        UserMapper mapper <span class="token operator">=</span> sqlSession<span class="token punctuation">.</span><span class="token function">getMapper</span><span class="token punctuation">(</span>UserMapper<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span>Object<span class="token operator">></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">,</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"pwd"</span><span class="token punctuation">,</span><span class="token string">"159357"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        mapper<span class="token punctuation">.</span><span class="token function">addUser2</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span>        sqlSession<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        sqlSession<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>map传递参数，直接在SQL中取出key！【parameterType=”map”】</p><p>对象传递参数，直接在sql中取对象的属性即可！【parameterType=”com.xyzhang.pojo.User”】</p><p>只有一个基本类型参数的情况下，可以直接在sql中取到【parameterType可以省略不写】</p><p>多个参数用map传递或者使用注解。</p><h4 id="3-7-模糊查询"><a href="#3-7-模糊查询" class="headerlink" title="3.7 模糊查询"></a>3.7 模糊查询</h4><p>需要注意对查询字符串进行转义：</p><ol><li>在sql语句中进行转义（可能会出现sql注入等情况）</li></ol><pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> mybatis<span class="token punctuation">.</span> <span class="token keyword">user</span> <span class="token keyword">where</span> name <span class="token operator">like</span> <span class="token string">"%"</span> <span class="token comment" spellcheck="true">#{value } "%";</span></code></pre><ol start="2"><li>在传入字符串时进行转义</li></ol><pre class=" language-java"><code class="language-java">mapper<span class="token punctuation">.</span><span class="token function">getUserLike</span><span class="token punctuation">(</span><span class="token string">"%张%"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="4-XML配置字段作用"><a href="#4-XML配置字段作用" class="headerlink" title="4. XML配置字段作用"></a>4. XML配置字段作用</h3><p>配置文件中的字段顺序必须遵循以下顺序</p><ul><li>configuration（配置）<br>properties（属性）<br>settings（设置）<br>typeAliases（类型别名）<br>typeHandlers（类型处理器）<br>objectFactory（对象工厂）<br>plugins（插件）<br>environments（环境配置）<br>environment（环境变量）<br>transactionManager（事务管理器）<br>dataSource（数据源）<br>databaseIdProvider（数据库厂商标识）<br>mappers（映射器）</li></ul><h4 id="4-1-environments（环境配置）"><a href="#4-1-environments（环境配置）" class="headerlink" title="4.1 environments（环境配置）"></a>4.1 environments（环境配置）</h4><p>MyBatis 可以配置成适应多种环境，但每个 SqlSessionFactory 实例只能选择一种环境。</p><ul><li><p>为了指定创建哪种环境，只要将它作为可选的参数传递给 SqlSessionFactoryBuilder 即可。</p><pre class=" language-java"><code class="language-java">SqlSessionFactory factory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SqlSessionFactoryBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span>reader<span class="token punctuation">,</span> environment<span class="token punctuation">)</span><span class="token punctuation">;</span>SqlSessionFactory factory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SqlSessionFactoryBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span>reader<span class="token punctuation">,</span> environment<span class="token punctuation">,</span> properties<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li><li><p>如果忽略了环境参数，那么默认环境将会被加载:</p><pre class=" language-java"><code class="language-java">SqlSessionFactory factory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SqlSessionFactoryBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span>reader<span class="token punctuation">)</span><span class="token punctuation">;</span>SqlSessionFactory factory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SqlSessionFactoryBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span>reader<span class="token punctuation">,</span> properties<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li></ul><p>核心配置文件中需要注意的关键点：</p><ul><li>默认使用的环境 ID（比如：default=”development”）。</li><li>每个 environment 元素定义的环境 ID（比如：id=”development”）。</li><li>事务管理器的配置（比如：type=”JDBC”）。</li><li>数据源的配置（比如：type=”POOLED”）。</li></ul><p><strong>事务管理器：（JDBC/MANAGED）</strong></p><p>📌如果使用Spring框架，不需手动配置会使用自带的管理器</p><p><strong>数据源：（UNPOOLED|POOLED|JNDI）</strong></p><p>POOLED：利用“池”的概念将 JDBC 连接对象组织起来，避免了创建新的连接实例时所必需的初始化和认证时间。 这是一种使得并发 Web 应用快速响应请求的流行处理方式。</p><p><strong>Mybatis默认的事务管理器为JDBC，数据源为POOLED连接池</strong></p><h4 id="4-2-properties（属性）"><a href="#4-2-properties（属性）" class="headerlink" title="4.2 properties（属性）"></a>4.2 properties（属性）</h4><p>作用：引用配置文件</p><p>这些属性都是可外部配置且可动态替换的，既可以在典型的 Java 属性文件中配置，亦可通过 properties 元素的子元素来传递。</p><p>编写外部配置文件</p><p>在Mybatis中的配置文件进行引用：</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>properties</span> <span class="token attr-name">resource</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>org/mybatis/example/config.properties<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token comment" spellcheck="true">&lt;!--可以在引入外部文件的基础上添加属性配置--></span>  <span class="token comment" spellcheck="true">&lt;!--但当字段重复时，优先使用外部配置文件--></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>username<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dev_user<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>password<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>F2Fa3!33TYyg<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>properties</span><span class="token punctuation">></span></span></code></pre><h4 id="4-3-typeAliases（类型别名）"><a href="#4-3-typeAliases（类型别名）" class="headerlink" title="4.3 typeAliases（类型别名）"></a>4.3 typeAliases（类型别名）</h4><p>作用：类型别名是为 Java 类型设置一个短的名字。 它只和 XML 配置有关，存在的意义仅在于用来<strong>减少类完全限定名</strong>的冗余</p><ol><li>给实体类起别名</li></ol><pre class=" language-xml"><code class="language-xml">    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>typeAliases</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>typeAlias</span> <span class="token attr-name">alias</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>User<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.xyzhang.pojo.User<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>typeAlias</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>typeAliases</span><span class="token punctuation">></span></span></code></pre><ol start="2"><li><p>给包起别名：在没有注解的情况下，会使用首字母小写的类名来作为它的别名</p><p>例如：com.xyzhang.pojo.User的别名就是user</p></li></ol><pre class=" language-xml"><code class="language-xml">    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>typeAliases</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>package</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.xyzhang.pojo<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>typeAliases</span><span class="token punctuation">></span></span></code></pre><p>实体类比较少的时候使用第一种方式，否则使用第二种。</p><p>第一种方式可以自定义别名，第二种只能跟随类名，但可通过注解方式进行命名更改<code>@Aliase</code>。</p><p>基本类型的别名在其映射类型的前面添加一个下划线：<code>_int   int</code></p><p>包装类型别名就是其映射类型首字母的小写：<code>int   Integer</code></p><h4 id="4-4-settings（设置）"><a href="#4-4-settings（设置）" class="headerlink" title="4.4 settings（设置）"></a>4.4 settings（设置）</h4><table><thead><tr><th>设置名</th><th align="center">描述</th><th>默认值</th></tr></thead><tbody><tr><td>cacheEnabled</td><td align="center">全局地开启或关闭配置文件中的所有映射器已经配置的任何缓存。</td><td>true</td></tr><tr><td>lazyLoadingEnabled</td><td align="center">延迟加载的全局开关。当开启时，所有关联对象都会延迟加载。 特定关联关系中可通过设置 <code>fetchType</code> 属性来覆盖该项的开关状态。</td><td>false</td></tr><tr><td>logImpl</td><td align="center">指定 MyBatis 所用日志的具体实现，未指定时将自动查找。</td><td></td></tr></tbody></table><h4 id="4-5-映射器mapper"><a href="#4-5-映射器mapper" class="headerlink" title="4.5 映射器mapper"></a>4.5 映射器mapper</h4><p>Mybaits行为配置完成后需要定义SQL映射语句，并告诉MyBatis查找这些语句的路径，可以使用<strong>相对于类路径的资源引用</strong>， 或完全限定资源定位符（包括 <code>file:///</code> 的 URL），或类名和包名等</p><p>方式一：【推荐使用】</p><pre class=" language-xml"><code class="language-xml">    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mappers</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mapper</span> <span class="token attr-name">resource</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.xyzhang.dao/UserMapper.xml<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mappers</span><span class="token punctuation">></span></span></code></pre><p>方式二：使用class文件绑定注册</p><ul><li>接口和Mapper配置文件必须同名且处于同一包下</li></ul><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mappers</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mapper</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>org.mybatis.builder.AuthorMapper<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mappers</span><span class="token punctuation">></span></span></code></pre><p>方式三：使用扫描包进行注入绑定</p><ul><li>接口和Mapper配置文件必须同名</li></ul><h4 id="4-6-属性名和字段名不一致"><a href="#4-6-属性名和字段名不一致" class="headerlink" title="4.6 属性名和字段名不一致"></a>4.6 属性名和字段名不一致</h4><p><img src="Mybatis%E5%B1%9E%E6%80%A7%E5%AD%97%E6%AE%B5%E4%B8%8D%E4%B8%80%E8%87%B4.png" alt="Mybatis属性字段不一致"></p><p>运行后发现不一致的属性获取到的值为null</p><p>原因：</p><pre class=" language-xml"><code class="language-xml">类型处理器找不到对应的字段select * from mybatis.user where id = #{id}select id,name,pwd from mybatis.user where id = #{id}</code></pre><p>解决方式：</p><ol><li>起别名：</li></ol><pre class=" language-xml"><code class="language-xml">select id,name,pwd as password from mybatis.user where id = #{id}</code></pre><ol start="2"><li><p><strong>ResultMap</strong>📌结果集映射</p><ol><li><p>将返回值类型由resultType更改为resultMap</p><pre class=" language-xml"><code class="language-xml">    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>getUserByID<span class="token punctuation">"</span></span> <span class="token attr-name">resultMap</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>UserMap<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        select * from mybatis.user where id = #{id}    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span></code></pre></li><li><p>添加结果集映射UserMap设置Type为其对应的类型</p><pre class=" language-xml"><code class="language-xml">    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resultMap</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>UserMap<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>User<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!--column：数据库中字段 property：实体类中属性--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>name<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>name<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>pwd<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>password<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resultMap</span><span class="token punctuation">></span></span></code></pre></li></ol></li></ol><ul><li><code>resultMap</code> 元素是 MyBatis 中最重要最强大的元素。</li><li>ResultMap 的设计思想是，对于简单的语句根本不需要配置显式的结果映射，而对于复杂一点的语句只需要描述它们的关系就行了。</li></ul><h3 id="5-日志"><a href="#5-日志" class="headerlink" title="5. 日志"></a>5. 日志</h3><h4 id="5-1-标准实现"><a href="#5-1-标准实现" class="headerlink" title="5.1 标准实现"></a>5.1 标准实现</h4><p>种类：</p><p>SLF4J | LOG4J【掌握】 | LOG4J2 | JDK_LOGGING | COMMONS_LOGGING | STDOUT_LOGGING 【掌握】| NO_LOGGING</p><p>在Mybatis中实现哪个日志，需要在设置中指定</p><pre class=" language-xml"><code class="language-xml">    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>settings</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!--标准的日志工厂实现--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>setting</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>logImpl<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>STDOUT_LOGGING<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>settings</span><span class="token punctuation">></span></span></code></pre><p><img src="Mybatis-logging.PNG" alt="Mybatis-logging"></p><h4 id="5-2-Log4J"><a href="#5-2-Log4J" class="headerlink" title="5.2 Log4J"></a>5.2 Log4J</h4><ul><li>可以控制日志信息输送的目的地是<a href="https://baike.baidu.com/item/%E6%8E%A7%E5%88%B6%E5%8F%B0/2438626">控制台</a>、文件、<a href="https://baike.baidu.com/item/GUI">GUI</a>组件，甚至是套接口服务器、<a href="https://baike.baidu.com/item/NT/3443842">NT</a>的事件记录器、<a href="https://baike.baidu.com/item/UNIX">UNIX</a> <a href="https://baike.baidu.com/item/Syslog">Syslog</a><a href="https://baike.baidu.com/item/%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/966835">守护进程</a>等</li><li>可以控制每一条日志的输出格式</li><li>通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程</li><li>可以通过一个<a href="https://baike.baidu.com/item/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/286550">配置文件</a>来灵活地进行配置，而不需要修改应用的代码</li></ul><ol><li><p>Maven导入Log4J包</p></li><li><p>在类路径下建立log4j.properties</p><pre class=" language-properties"><code class="language-properties"><span class="token comment" spellcheck="true">### Log4j配置 ###</span><span class="token comment" spellcheck="true">#定义log4j的输出级别和输出目的地（目的地可以自定义名称，和后面的对应）</span><span class="token comment" spellcheck="true">#[ level ] , appenderName1 , appenderName2</span><span class="token attr-name">log4j.rootLogger</span><span class="token punctuation">=</span><span class="token attr-value">DEBUG,console,file</span><span class="token comment" spellcheck="true">#-----------------------------------#</span><span class="token comment" spellcheck="true">#1 定义日志输出目的地为控制台</span><span class="token attr-name">log4j.appender.console</span> <span class="token punctuation">=</span> <span class="token attr-value">org.apache.log4j.ConsoleAppender</span><span class="token attr-name">log4j.appender.console.Target</span> <span class="token punctuation">=</span> <span class="token attr-value">System.out</span><span class="token attr-name">log4j.appender.console.Threshold</span><span class="token punctuation">=</span><span class="token attr-value">DEBUG</span><span class="token comment" spellcheck="true">####可以灵活地指定日志输出格式，下面一行是指定具体的格式 ###</span><span class="token comment" spellcheck="true">#%c: 输出日志信息所属的类目，通常就是所在类的全名</span><span class="token comment" spellcheck="true">#%m: 输出代码中指定的消息,产生的日志具体信息</span><span class="token comment" spellcheck="true">#%n: 输出一个回车换行符，Windows平台为"/r/n"，Unix平台为"/n"输出日志信息换行</span><span class="token attr-name">log4j.appender.console.layout</span> <span class="token punctuation">=</span> <span class="token attr-value">org.apache.log4j.PatternLayout</span><span class="token attr-name">log4j.appender.console.layout.ConversionPattern</span><span class="token punctuation">=</span><span class="token attr-value">[%c]-%m%n</span><span class="token comment" spellcheck="true">#-----------------------------------#</span><span class="token comment" spellcheck="true">#2 文件大小到达指定尺寸的时候产生一个新的文件</span><span class="token attr-name">log4j.appender.file</span> <span class="token punctuation">=</span> <span class="token attr-value">org.apache.log4j.RollingFileAppender</span><span class="token comment" spellcheck="true">#日志文件输出目录</span><span class="token attr-name">log4j.appender.file.File</span><span class="token punctuation">=</span><span class="token attr-value">log/info.log</span><span class="token comment" spellcheck="true">#定义文件最大大小</span><span class="token attr-name">log4j.appender.file.MaxFileSize</span><span class="token punctuation">=</span><span class="token attr-value">10mb</span><span class="token comment" spellcheck="true">###输出日志信息###</span><span class="token comment" spellcheck="true">#最低级别</span><span class="token attr-name">log4j.appender.file.Threshold</span><span class="token punctuation">=</span><span class="token attr-value">ERROR</span><span class="token attr-name">log4j.appender.file.layout</span><span class="token punctuation">=</span><span class="token attr-value">org.apache.log4j.PatternLayout</span><span class="token attr-name">log4j.appender.file.layout.ConversionPattern</span><span class="token punctuation">=</span><span class="token attr-value">[%p][%d{yy-MM-dd}][%c]%m%n</span><span class="token comment" spellcheck="true">#-----------------------------------#</span><span class="token comment" spellcheck="true">#3 druid</span><span class="token attr-name">log4j.logger.druid.sql</span><span class="token punctuation">=</span><span class="token attr-value">INFO</span><span class="token attr-name">log4j.logger.druid.sql.DataSource</span><span class="token punctuation">=</span><span class="token attr-value">info</span><span class="token attr-name">log4j.logger.druid.sql.Connection</span><span class="token punctuation">=</span><span class="token attr-value">info</span><span class="token attr-name">log4j.logger.druid.sql.Statement</span><span class="token punctuation">=</span><span class="token attr-value">info</span><span class="token attr-name">log4j.logger.druid.sql.ResultSet</span><span class="token punctuation">=</span><span class="token attr-value">info</span><span class="token comment" spellcheck="true">#4 mybatis 显示SQL语句部分</span><span class="token attr-name">log4j.logger.org.mybatis</span><span class="token punctuation">=</span><span class="token attr-value">DEBUG</span><span class="token attr-name">log4j.logger.java.sql</span><span class="token punctuation">=</span><span class="token attr-value">DEBUG</span><span class="token attr-name">log4j.logger.java.sql.Statement</span><span class="token punctuation">=</span><span class="token attr-value">DEBUG</span><span class="token attr-name">log4j.logger.java.sql.ResultSet</span><span class="token punctuation">=</span><span class="token attr-value">DEBUG</span><span class="token attr-name">log4j.logger.java.sql.PreparedStatement</span><span class="token punctuation">=</span><span class="token attr-value">DEBUG</span></code></pre></li><li><p>在核心配置文件的settings字段中，配置log4j为日志工厂的实现</p></li></ol><h4 id="简单使用："><a href="#简单使用：" class="headerlink" title="简单使用："></a>简单使用：</h4><ol><li><p>在要使用Log4j的类中引入<code>import org.apache.log4j.Logger;</code></p></li><li><p>定义日志对象，参数为当前类的class</p><p><code>static Logger logger = Logger.getLogger(UserDaoTest.class);</code></p></li><li><p>区分日志级别</p><pre class=" language-java"><code class="language-java">logger<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"info:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> logger<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"debug:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>logger<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"error:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li></ol><h3 id="6-分页"><a href="#6-分页" class="headerlink" title="6. 分页"></a>6. 分页</h3><h4 id="6-1-使用limit分页"><a href="#6-1-使用limit分页" class="headerlink" title="6.1 使用limit分页"></a>6.1 使用limit分页</h4><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">user</span> <span class="token keyword">limit</span> startIndex<span class="token punctuation">,</span>pageSize</code></pre><h4 id="6-2-使用Mybatis实现分页"><a href="#6-2-使用Mybatis实现分页" class="headerlink" title="6.2 使用Mybatis实现分页"></a>6.2 使用Mybatis实现分页</h4><ol><li><p>接口</p></li><li><p>Mapper.xml</p><pre class=" language-xml"><code class="language-xml">    <span class="token comment" spellcheck="true">&lt;!--分页--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>getUserByLimit<span class="token punctuation">"</span></span> <span class="token attr-name">parameterType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>map<span class="token punctuation">"</span></span> <span class="token attr-name">resultMap</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>userMap<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        select * from mybatis.user limit #{startIndex} , #{pageSize};    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span></code></pre></li></ol><ol start="3"><li>测试</li></ol><h4 id="6-3-使用RowBounds分页【不推荐】"><a href="#6-3-使用RowBounds分页【不推荐】" class="headerlink" title="6.3 使用RowBounds分页【不推荐】"></a>6.3 使用RowBounds分页【不推荐】</h4><h3 id="7-一对多和多对一的处理"><a href="#7-一对多和多对一的处理" class="headerlink" title="7. 一对多和多对一的处理"></a>7. 一对多和多对一的处理</h3><ul><li>多个学生，对应一个老师</li><li>对于学生这边而言，<strong>关联</strong>…多个学生，关联一个老师【多对一】</li><li>对于老师而言，<strong>集合</strong>，一个老师对应很多学生【一对多】</li></ul><h4 id="7-1-多对一的处理"><a href="#7-1-多对一的处理" class="headerlink" title="7.1 多对一的处理"></a>7.1 多对一的处理</h4><p>多对一环境搭建：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Teacher</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> id<span class="token punctuation">;</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> id<span class="token punctuation">;</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//多个学生可以是同一个老师，即多对一</span>    <span class="token keyword">private</span> Teacher teacher<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ol><li><p>按<strong>查询嵌套</strong>处理</p><pre class=" language-xml"><code class="language-xml">    <span class="token comment" spellcheck="true">&lt;!--    需求：获取所有学生及对应老师的信息    思路：        1. 获取所有学生的信息        2. 根据获取的学生信息的老师ID->获取该老师的信息        3. 思考问题，这样学生的结果集中应该包含老师，该如何处理呢，数据库中我们一般使用关联查询？            1. 做一个结果集映射：StudentTeacher            2. StudentTeacher结果集的类型为 Student            3. 学生中老师的属性为teacher，对应数据库中为tid。               多个 [1,...）学生关联一个老师=> 一对一，一对多            4. 查看官网找到：association – 一个复杂类型的关联；使用它来处理关联查询    --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>getStudents<span class="token punctuation">"</span></span> <span class="token attr-name">resultMap</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>StudentTeacher<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>      select * from student    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resultMap</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>StudentTeacher<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Student<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!--association关联属性  property属性名 javaType属性类型 column在多的一方的表中的列名--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>association</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>teacher<span class="token punctuation">"</span></span>  <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>tid<span class="token punctuation">"</span></span> <span class="token attr-name">javaType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Teacher<span class="token punctuation">"</span></span> <span class="token attr-name">select</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>getTeacher<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resultMap</span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!--    这里传递过来的id，只有一个属性的时候，下面可以写任何值    association中column多参数配置：        column="{key=value,key=value}"        其实就是键值对的形式，key是传给下个sql的取值名称，value是片段一中sql查询的字段名。    --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>getTeacher<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>teacher<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        select * from teacher where id = #{id}    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span></code></pre></li><li><p>按照查询<strong>结果</strong>嵌套</p><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!--按查询结果嵌套处理思路：    1. 直接查询出结果，进行结果集的映射--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>getStudents2<span class="token punctuation">"</span></span> <span class="token attr-name">resultMap</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>StudentTeacher2<span class="token punctuation">"</span></span> <span class="token punctuation">></span></span>    select s.id sid, s.name sname , t.name tname    from student s,teacher t    where s.tid = t.id<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!--需要对应数据库列名与别名--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resultMap</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>StudentTeacher2<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Student<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>sid<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>name<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>sname<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token comment" spellcheck="true">&lt;!--关联对象property 关联对象在Student实体类中的属性--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>association</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>teacher<span class="token punctuation">"</span></span> <span class="token attr-name">javaType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Teacher<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>name<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>tname<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>association</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resultMap</span><span class="token punctuation">></span></span></code></pre></li></ol><h4 id="7-2-一对多的处理"><a href="#7-2-一对多的处理" class="headerlink" title="7.2 一对多的处理"></a>7.2 一对多的处理</h4><p>理解：</p><ul><li>一个老师拥有多个学生</li><li>如果对于老师这边，就是一个一对多的现象，即从一个老师下面拥有一群学生（集合）</li></ul><p>环境搭建：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> id<span class="token punctuation">;</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> tid<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Teacher</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> id<span class="token punctuation">;</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//一个老师多个学生</span>    <span class="token keyword">private</span> List<span class="token operator">&lt;</span>Student<span class="token operator">></span> students<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ol><li><p>按结果嵌套处理</p><pre class=" language-xml"><code class="language-xml">    <span class="token comment" spellcheck="true">&lt;!--    思路:        1. 从学生表和老师表中查出学生id，学生姓名，老师姓名        2. 对查询出来的操作做结果集映射            1. 集合的话，使用collection！                JavaType和ofType都是用来指定对象类型的                JavaType是用来指定pojo中属性的类型                ofType指定的是映射到list集合属性中pojo的类型。    --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>getTeacher<span class="token punctuation">"</span></span> <span class="token attr-name">resultMap</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>TeacherStudent<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        select s.id sid, s.name sname , t.name tname, t.id tid        from student s,teacher t        where s.tid = t.id and t.id=#{id}    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resultMap</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>TeacherStudent<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Teacher<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span>  <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>name<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>tname<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>collection</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>students<span class="token punctuation">"</span></span> <span class="token attr-name">ofType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Student<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>sid<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>name<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>sname<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>tid<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>tid<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>collection</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resultMap</span><span class="token punctuation">></span></span></code></pre></li><li><p>按查询嵌套处理</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>getTeacher2<span class="token punctuation">"</span></span> <span class="token attr-name">resultMap</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>TeacherStudent2<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  select * from teacher where id = #{id}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resultMap</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>TeacherStudent2<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Teacher<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!--column是一对多的外键 , 写的是一的主键的列名--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>collection</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>students<span class="token punctuation">"</span></span> <span class="token attr-name">javaType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ArrayList<span class="token punctuation">"</span></span> <span class="token attr-name">ofType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Student<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token attr-name">select</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>getStudentByTeacherId<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resultMap</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>getStudentByTeacherId<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Student<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    select * from student where tid = #{id}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span></code></pre></li></ol><h4 id="7-3-总结"><a href="#7-3-总结" class="headerlink" title="7.3 总结"></a>7.3 总结</h4><ol><li>关联-association</li><li>集合-collection</li><li>所以association是用于一对一和多对一，而collection是用于一对多的关系</li><li>JavaType和ofType都是用来指定对象类型的<ul><li>JavaType是用来指定pojo中属性的类型</li><li>ofType指定的是映射到list集合属性中pojo的类型。</li></ul></li></ol><h3 id="8-动态SQL"><a href="#8-动态SQL" class="headerlink" title="8. 动态SQL"></a>8. 动态SQL</h3><p>本质就是拼接sql语句，根据不同的查询条件生成不同sql语句</p><p>常用标签：</p><ul><li>if</li><li>choose (when, otherwise)</li><li>trim (where, set)</li><li>foreach</li></ul><ol><li><p>导包</p></li><li><p>编写配置文件<code>mybatis-config.xml</code></p></li><li><p>编写实体类(配置文件中有一个设置方法可以将数据库中的命名格式自动转换为驼峰式命名)<code>&lt;setting name="mapUnderscoreToCamelCase" value="true"/&gt;</code></p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Data</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Blog</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> String id<span class="token punctuation">;</span>    <span class="token keyword">private</span> String title<span class="token punctuation">;</span>    <span class="token keyword">private</span> String author<span class="token punctuation">;</span>    <span class="token keyword">private</span> Date createTime<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> views<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>编写实体类对应的Mapper接口和Mapper.xml</p></li></ol><h4 id="8-1-IF语句"><a href="#8-1-IF语句" class="headerlink" title="8.1 IF语句"></a>8.1 IF语句</h4><p>这条语句提供了一种可选的查找文本功能。如果没有传入“title”，那么所有满足“1=1”（所有）的BLOG都会返回；反之若传入了“title”，那么就会对“title”一列进行模糊查找并返回 BLOG 结果</p><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!--需求1：根据作者名字和博客名字来查询博客！如果作者名字为空，那么只根据博客名字查询，反之，则根据作者名来查询select * from blog where title = #{title} and author = #{author}--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>queryBlogIF<span class="token punctuation">"</span></span> <span class="token attr-name">parameterType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>map<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>blog<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        select * from mybatis.blog where 1=1        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>if</span> <span class="token attr-name">test</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>title !<span class="token punctuation">=</span> null<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            and title = #{title}        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>if</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>if</span> <span class="token attr-name">test</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>author !<span class="token punctuation">=</span> null<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            and author = #{author}        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>if</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span></code></pre><h4 id="8-2-trim-where-set"><a href="#8-2-trim-where-set" class="headerlink" title="8.2 trim, where, set"></a>8.2 trim, where, set</h4><p><em>where</em> 元素只会在至少有一个子元素的条件返回 SQL 子句的情况下才去插入“WHERE”子句。而且，若语句的开头为“AND”或“OR”，<em>where</em> 元素也会将它们去除。(相当于辅助sql语句的生成)</p><pre class=" language-xml"><code class="language-xml">    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>queryBlogIF<span class="token punctuation">"</span></span> <span class="token attr-name">parameterType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>map<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>blog<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        select * from mybatis.blog        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>where</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>if</span> <span class="token attr-name">test</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>title !<span class="token punctuation">=</span> null<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                title = #{title}            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>if</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>if</span> <span class="token attr-name">test</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>author !<span class="token punctuation">=</span> null<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                and author = #{author}            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>if</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>where</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span></code></pre><p>用于动态更新语句(update语句)的解决方案叫做 <em>set</em>。<em>set</em> 元素可以用于动态包含需要更新的列，而舍去其它的。</p><p>若最后一个“if”没有匹配上而前面的匹配上，SQL 语句的最后就会有一个逗号遗留此时set元素就会自动删掉无关的逗号</p><pre class=" language-xml"><code class="language-xml">    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>update</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>updateBlog<span class="token punctuation">"</span></span> <span class="token attr-name">parameterType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>map<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        update mybatis.blog        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>set</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>if</span> <span class="token attr-name">test</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>title !<span class="token punctuation">=</span> null<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>title = #{title},<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>if</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>if</span> <span class="token attr-name">test</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>author !<span class="token punctuation">=</span> null<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>author = #{author},<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>if</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>if</span> <span class="token attr-name">test</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>views !<span class="token punctuation">=</span> null<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>views = #{views}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>if</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>set</span><span class="token punctuation">></span></span>        where id = #{id}    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>update</span><span class="token punctuation">></span></span></code></pre><ul><li><p>以上两种操作都可以使用trim元素来实现，where元素采用<em>prefixOverrides</em> 移除前缀值，并且插入 <em>prefix</em> 属性中指定的内容，set元素则采用suffixOverrides=”,”，移除后缀值</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>trim</span> <span class="token attr-name">prefix</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>WHERE<span class="token punctuation">"</span></span> <span class="token attr-name">prefixOverrides</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>AND |OR <span class="token punctuation">"</span></span><span class="token punctuation">></span></span>...<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>trim</span><span class="token punctuation">></span></span></code></pre></li></ul><blockquote><p>动态SQL本质还是SQL语句，只是在SQL层面执行一个逻辑代码</p></blockquote><h4 id="8-3-choose-when-otherwise"><a href="#8-3-choose-when-otherwise" class="headerlink" title="8.3 choose, when, otherwise"></a>8.3 choose, when, otherwise</h4><p>有时我们不想应用到所有的条件语句，而只想从中择其一项。针对这种情况，MyBatis 提供了 choose 元素，它有点像 Java 中的 switch 语句。</p><pre class=" language-xml"><code class="language-xml">    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>queryBlogChoose<span class="token punctuation">"</span></span> <span class="token attr-name">parameterType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>map<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>blog<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        select * from mybatis.blog        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>choose</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>when</span> <span class="token attr-name">test</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>author !<span class="token punctuation">=</span> null<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                author = #{author};            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>when</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>when</span> <span class="token attr-name">test</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>title !<span class="token punctuation">=</span> null<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                title = #{title};            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>when</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>otherwise</span><span class="token punctuation">></span></span>                views = #{views};            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>otherwise</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>choose</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span></code></pre><h4 id="8-4-SQL片段"><a href="#8-4-SQL片段" class="headerlink" title="8.4 SQL片段"></a>8.4 SQL片段</h4><p>相当于定义函数，抽取公共部分，方便复用</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>sql</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>if-title-author<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>if</span> <span class="token attr-name">test</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>title !<span class="token punctuation">=</span> null<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        title = #{title}    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>if</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>if</span> <span class="token attr-name">test</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>author !<span class="token punctuation">=</span> null<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        and author = #{author}    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>if</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>sql</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!--使用include进行引用--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>queryBlogIf<span class="token punctuation">"</span></span> <span class="token attr-name">parameterType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>map<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>blog<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    select * from blog    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>where</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!-- 引用 sql 片段，如果refid 指定的不在本文件中，那么需要在前面加上 namespace --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>include</span> <span class="token attr-name">refid</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>if-title-author<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>include</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!-- 在这里还可以引用其他的 sql 片段 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>where</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span></code></pre><h4 id="8-5-foreach"><a href="#8-5-foreach" class="headerlink" title="8.5 foreach"></a>8.5 foreach</h4><p><em>foreach</em> 元素的功能非常强大，它允许你指定一个集合，声明可以在元素体内使用的集合项（item）和索引（index）变量。它也允许你指定开头与结尾的字符串以及在迭代结果之间放置分隔符。</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>queryBlogForeach<span class="token punctuation">"</span></span> <span class="token attr-name">parameterType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>map<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>blog<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    select * from blog    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>where</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!--        与Java中foreach循环类似        collection:指定输入对象中的集合属性        item:每次遍历生成的对象        open:开始遍历时的拼接字符串        close:结束时拼接的字符串        separator:遍历对象之间需要拼接的字符串        select * from blog where 1=1 and (id=1 or id=2 or id=3)      --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>foreach</span> <span class="token attr-name">collection</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ids<span class="token punctuation">"</span></span>  <span class="token attr-name">item</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token attr-name">open</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>and (<span class="token punctuation">"</span></span> <span class="token attr-name">close</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>)<span class="token punctuation">"</span></span> <span class="token attr-name">separator</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>or<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            id=#{id}        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>foreach</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>where</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span></code></pre><h3 id="9-缓存"><a href="#9-缓存" class="headerlink" title="9. 缓存"></a>9. 缓存</h3><h4 id="9-1-一级缓存"><a href="#9-1-一级缓存" class="headerlink" title="9.1 一级缓存"></a>9.1 一级缓存</h4><p>缓存失效的情况：</p><ul><li>每个sqlSession中的缓存相互独立，不同sqlSession缓存也不互通</li><li>sqlSession相同，查询条件不同</li><li>sqlSession相同，两次查询之间执行了增删改操作</li><li>sqlSession相同，手动清除一级缓存</li></ul><p>一级缓存默认开启，只在一个sqlSession中有效，也就是拿到链接到关闭连接的过程</p><h4 id="9-2-二级缓存（全局缓存）"><a href="#9-2-二级缓存（全局缓存）" class="headerlink" title="9.2 二级缓存（全局缓存）"></a>9.2 二级缓存（全局缓存）</h4><ul><li>基于namespace级别的缓存，一个名称空间，对应一个二级缓存；</li><li>工作机制<ul><li>一个会话查询一条数据，这个数据就会被放在当前会话的一级缓存中；</li><li>如果当前会话关闭了，这个会话对应的一级缓存就没了；但是我们想要的是，会话关闭了，一级缓存中的数据被保存到二级缓存中；</li><li>新的会话查询信息，就可以从二级缓存中获取内容；</li><li>不同的mapper查出的数据会放在自己对应的缓存（map）中；</li></ul></li></ul><p>使用步骤：</p><ol><li><p>在核心配置文件中开启全局缓存<code>mybatis-config.xml</code></p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>setting</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>cacheEnabled<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span></code></pre></li><li><p>每个mapper.xml中配置使用二级缓存<code>xxxMapper.xml</code></p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>cache</span>  <span class="token attr-name">eviction</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>FIFO<span class="token punctuation">"</span></span>  <span class="token attr-name">flushInterval</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>60000<span class="token punctuation">"</span></span>  <span class="token attr-name">size</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>512<span class="token punctuation">"</span></span>  <span class="token attr-name">readOnly</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span></code></pre><p>这个更高级的配置创建了一个 FIFO 缓存，每隔 60 秒刷新，最多可以存储结果对象或列表的 512 个引用，而且返回的对象被认为是只读的，因此对它们进行修改可能会在不同线程中的调用者产生冲突。</p></li></ol><p>结论：</p><ul><li>只要开启了二级缓存，我们在同一个Mapper中的查询，可以在二级缓存中拿到数据</li><li>查出的数据都会被默认先放在一级缓存中</li><li>只有会话提交或者关闭以后，一级缓存中的数据才会转到二级缓存中</li></ul><h4 id="9-3-缓存原理"><a href="#9-3-缓存原理" class="headerlink" title="9.3 缓存原理"></a>9.3 缓存原理</h4><ol><li>查询二级缓存中是否存在，存在直接返回</li><li>查询一级缓存中是否存在，存在直接返回</li><li>查询数据库</li></ol><p><img src="Mybatis-%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86.png" alt="Mybatis-缓存原理"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>RestfulAPI最佳实践</title>
      <link href="/xyzhangblog/2020/12/31/java/springboot/restful-api-zui-jia-shi-jian/restfulapi-zui-jia-shi-jian/"/>
      <url>/xyzhangblog/2020/12/31/java/springboot/restful-api-zui-jia-shi-jian/restfulapi-zui-jia-shi-jian/</url>
      
        <content type="html"><![CDATA[<p>[转载] 原创出处 <a href="http://www.ruanyifeng.com/blog/2018/10/restful-api-best-practices.html">http://www.ruanyifeng.com/blog/2018/10/restful-api-best-practices.html</a> 「阮一峰」</p><h2 id="一、URL-设计"><a href="#一、URL-设计" class="headerlink" title="一、URL 设计"></a>一、URL 设计</h2><h3 id="1-1-动词-宾语"><a href="#1-1-动词-宾语" class="headerlink" title="1.1 动词 + 宾语"></a>1.1 动词 + 宾语</h3><p>RESTful 的核心思想就是，客户端发出的数据操作指令都是”动词 + 宾语”的结构。比如，<code>GET /articles</code>这个命令，<code>GET</code>是动词，<code>/articles</code>是宾语。</p><p>动词通常就是五种 HTTP 方法，对应 CRUD 操作。</p><blockquote><ul><li>GET：读取（Read）</li><li>POST：新建（Create）</li><li>PUT：更新（Update）</li><li>PATCH：更新（Update），通常是部分更新</li><li>DELETE：删除（Delete）</li></ul></blockquote><p>根据 HTTP 规范，动词一律大写。</p><h3 id="1-2-动词的覆盖"><a href="#1-2-动词的覆盖" class="headerlink" title="1.2 动词的覆盖"></a>1.2 动词的覆盖</h3><p>有些客户端只能使用<code>GET</code>和<code>POST</code>这两种方法。服务器必须接受<code>POST</code>模拟其他三个方法（<code>PUT</code>、<code>PATCH</code>、<code>DELETE</code>）。</p><p>这时，客户端发出的 HTTP 请求，要加上<code>X-HTTP-Method-Override</code>属性，告诉服务器应该使用哪一个动词，覆盖<code>POST</code>方法。</p><blockquote><pre class=" language-http"><code class="language-http">POST /api/Person/4 HTTP/1.1  <span class="token header-name keyword">X-HTTP-Method-Override:</span> PUT</code></pre></blockquote><p>上面代码中，<code>X-HTTP-Method-Override</code>指定本次请求的方法是<code>PUT</code>，而不是<code>POST</code>。</p><h3 id="1-3-宾语必须是名词"><a href="#1-3-宾语必须是名词" class="headerlink" title="1.3 宾语必须是名词"></a>1.3 宾语必须是名词</h3><p>宾语就是 API 的 URL，是 HTTP 动词作用的对象。它应该是名词，不能是动词。比如，<code>/articles</code>这个 URL 就是正确的，而下面的 URL 不是名词，所以都是错误的。</p><blockquote><ul><li>/getAllCars</li><li>/createNewCar</li><li>/deleteAllRedCars</li></ul></blockquote><h3 id="1-4-复数-URL"><a href="#1-4-复数-URL" class="headerlink" title="1.4 复数 URL"></a>1.4 复数 URL</h3><p>既然 URL 是名词，那么应该使用复数，还是单数？</p><p>这没有统一的规定，但是常见的操作是读取一个集合，比如<code>GET /articles</code>（读取所有文章），这里明显应该是复数。</p><p>为了统一起见，建议都使用复数 URL，比如<code>GET /articles/2</code>要好于<code>GET /article/2</code>。</p><h3 id="1-5-避免多级-URL"><a href="#1-5-避免多级-URL" class="headerlink" title="1.5 避免多级 URL"></a>1.5 避免多级 URL</h3><p>常见的情况是，资源需要多级分类，因此很容易写出多级的 URL，比如获取某个作者的某一类文章。</p><blockquote><pre class=" language-http"><code class="language-http">GET /authors/12/categories/2</code></pre></blockquote><p>这种 URL 不利于扩展，语义也不明确，往往要想一会，才能明白含义。</p><p>更好的做法是，除了第一级，其他级别都用查询字符串表达。</p><blockquote><pre class=" language-http"><code class="language-http">GET /authors/12?categories=2</code></pre></blockquote><p>下面是另一个例子，查询已发布的文章。你可能会设计成下面的 URL。</p><blockquote><pre class=" language-http"><code class="language-http">GET /articles/published</code></pre></blockquote><p>查询字符串的写法明显更好。</p><blockquote><pre class=" language-http"><code class="language-http">GET /articles?published=true</code></pre></blockquote><h2 id="二、状态码"><a href="#二、状态码" class="headerlink" title="二、状态码"></a>二、状态码</h2><h3 id="2-1-状态码必须精确"><a href="#2-1-状态码必须精确" class="headerlink" title="2.1 状态码必须精确"></a>2.1 状态码必须精确</h3><p>客户端的每一次请求，服务器都必须给出回应。回应包括 HTTP 状态码和数据两部分。</p><p>HTTP 状态码就是一个三位数，分成五个类别。</p><blockquote><ul><li><code>1xx</code>：相关信息</li><li><code>2xx</code>：操作成功</li><li><code>3xx</code>：重定向</li><li><code>4xx</code>：客户端错误</li><li><code>5xx</code>：服务器错误</li></ul></blockquote><p>这五大类总共包含<a href="https://en.wikipedia.org/wiki/List_of_HTTP_status_codes">100多种</a>状态码，覆盖了绝大部分可能遇到的情况。每一种状态码都有标准的（或者约定的）解释，客户端只需查看状态码，就可以判断出发生了什么情况，所以服务器应该返回尽可能精确的状态码。</p><p>API 不需要<code>1xx</code>状态码，下面介绍其他四类状态码的精确含义。</p><h3 id="2-2-2xx-状态码"><a href="#2-2-2xx-状态码" class="headerlink" title="2.2 2xx 状态码"></a>2.2 2xx 状态码</h3><p><code>200</code>状态码表示操作成功，但是不同的方法可以返回更精确的状态码。</p><blockquote><ul><li>GET: 200 OK</li><li>POST: 201 Created</li><li>PUT: 200 OK</li><li>PATCH: 200 OK</li><li>DELETE: 204 No Content</li></ul></blockquote><p>上面代码中，<code>POST</code>返回<code>201</code>状态码，表示生成了新的资源；<code>DELETE</code>返回<code>204</code>状态码，表示资源已经不存在。</p><p>此外，<code>202 Accepted</code>状态码表示服务器已经收到请求，但还未进行处理，会在未来再处理，通常用于异步操作。下面是一个例子。</p><blockquote><pre class=" language-http"><code class="language-http"><span class="token response-status">HTTP/1.1 <span class="token property">202 Accepted</span></span>{  "task": {    "href": "/api/company/job-management/jobs/2130040",    "id": "2130040"  }}</code></pre></blockquote><h3 id="2-3-3xx-状态码"><a href="#2-3-3xx-状态码" class="headerlink" title="2.3 3xx 状态码"></a>2.3 3xx 状态码</h3><p>API 用不到<code>301</code>状态码（永久重定向）和<code>302</code>状态码（暂时重定向，<code>307</code>也是这个含义），因为它们可以由应用级别返回，浏览器会直接跳转，API 级别可以不考虑这两种情况。</p><p>API 用到的<code>3xx</code>状态码，主要是<code>303 See Other</code>，表示参考另一个 URL。它与<code>302</code>和<code>307</code>的含义一样，也是”暂时重定向”，区别在于<code>302</code>和<code>307</code>用于<code>GET</code>请求，而<code>303</code>用于<code>POST</code>、<code>PUT</code>和<code>DELETE</code>请求。收到<code>303</code>以后，浏览器不会自动跳转，而会让用户自己决定下一步怎么办。下面是一个例子。</p><blockquote><pre class=" language-http"><code class="language-http"><span class="token response-status">HTTP/1.1 <span class="token property">303 See Other</span></span><span class="token header-name keyword">Location:</span> /api/orders/12345</code></pre></blockquote><h3 id="2-4-4xx-状态码"><a href="#2-4-4xx-状态码" class="headerlink" title="2.4 4xx 状态码"></a>2.4 4xx 状态码</h3><p><code>4xx</code>状态码表示客户端错误，主要有下面几种。</p><p><code>400 Bad Request</code>：服务器不理解客户端的请求，未做任何处理。</p><p><code>401 Unauthorized</code>：用户未提供身份验证凭据，或者没有通过身份验证。</p><p><code>403 Forbidden</code>：用户通过了身份验证，但是不具有访问资源所需的权限。</p><p><code>404 Not Found</code>：所请求的资源不存在，或不可用。</p><p><code>405 Method Not Allowed</code>：用户已经通过身份验证，但是所用的 HTTP 方法不在他的权限之内。</p><p><code>410 Gone</code>：所请求的资源已从这个地址转移，不再可用。</p><p><code>415 Unsupported Media Type</code>：客户端要求的返回格式不支持。比如，API 只能返回 JSON 格式，但是客户端要求返回 XML 格式。</p><p><code>422 Unprocessable Entity</code> ：客户端上传的附件无法处理，导致请求失败。</p><p><code>429 Too Many Requests</code>：客户端的请求次数超过限额。</p><h3 id="2-5-5xx-状态码"><a href="#2-5-5xx-状态码" class="headerlink" title="2.5 5xx 状态码"></a>2.5 5xx 状态码</h3><p><code>5xx</code>状态码表示服务端错误。一般来说，API 不会向用户透露服务器的详细信息，所以只要两个状态码就够了。</p><p><code>500 Internal Server Error</code>：客户端请求有效，服务器处理时发生了意外。</p><p><code>503 Service Unavailable</code>：服务器无法处理请求，一般用于网站维护状态。</p><h2 id="三、服务器回应"><a href="#三、服务器回应" class="headerlink" title="三、服务器回应"></a>三、服务器回应</h2><h3 id="3-1-不要返回纯本文"><a href="#3-1-不要返回纯本文" class="headerlink" title="3.1 不要返回纯本文"></a>3.1 不要返回纯本文</h3><p>API 返回的数据格式，不应该是纯文本，而应该是一个 JSON 对象，因为这样才能返回标准的结构化数据。所以，服务器回应的 HTTP 头的<code>Content-Type</code>属性要设为<code>application/json</code>。</p><p>客户端请求时，也要明确告诉服务器，可以接受 JSON 格式，即请求的 HTTP 头的<code>ACCEPT</code>属性也要设成<code>application/json</code>。下面是一个例子。</p><blockquote><pre class=" language-http"><code class="language-http">GET /orders/2 HTTP/1.1 <span class="token header-name keyword">Accept:</span> application/json</code></pre></blockquote><h3 id="3-2-发生错误时，不要返回-200-状态码"><a href="#3-2-发生错误时，不要返回-200-状态码" class="headerlink" title="3.2 发生错误时，不要返回 200 状态码"></a>3.2 发生错误时，不要返回 200 状态码</h3><p>有一种不恰当的做法是，即使发生错误，也返回<code>200</code>状态码，把错误信息放在数据体里面，就像下面这样。</p><blockquote><pre class=" language-http"><code class="language-http"><span class="token response-status">HTTP/1.1 <span class="token property">200 OK</span></span><span class="token header-name keyword">Content-Type:</span> application/json<span class="token application/json"><span class="token punctuation">{</span>  <span class="token string">"status"</span><span class="token punctuation">:</span> <span class="token string">"failure"</span><span class="token punctuation">,</span>  <span class="token string">"data"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>    <span class="token string">"error"</span><span class="token punctuation">:</span> <span class="token string">"Expected at least two items in list."</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></span></code></pre></blockquote><p>上面代码中，解析数据体以后，才能得知操作失败。</p><p>这张做法实际上取消了状态码，这是完全不可取的。正确的做法是，状态码反映发生的错误，具体的错误信息放在数据体里面返回。下面是一个例子。</p><blockquote><pre class=" language-http"><code class="language-http"><span class="token response-status">HTTP/1.1 <span class="token property">400 Bad Request</span></span><span class="token header-name keyword">Content-Type:</span> application/json<span class="token application/json"><span class="token punctuation">{</span>  <span class="token string">"error"</span><span class="token punctuation">:</span> <span class="token string">"Invalid payoad."</span><span class="token punctuation">,</span>  <span class="token string">"detail"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>     <span class="token string">"surname"</span><span class="token punctuation">:</span> <span class="token string">"This field is required."</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></span></code></pre></blockquote><h3 id="3-3-提供链接"><a href="#3-3-提供链接" class="headerlink" title="3.3 提供链接"></a>3.3 提供链接</h3><p>API 的使用者未必知道，URL 是怎么设计的。一个解决方法就是，在回应中，给出相关链接，便于下一步操作。这样的话，用户只要记住一个 URL，就可以发现其他的 URL。这种方法叫做 HATEOAS。</p><p>举例来说，GitHub 的 API 都在 <a href="https://api.github.com/">api.github.com</a> 这个域名。访问它，就可以得到其他 URL。</p><blockquote><pre class=" language-http"><code class="language-http">{  ...  "feeds_url": "https://api.github.com/feeds",  "followers_url": "https://api.github.com/user/followers",  "following_url": "https://api.github.com/user/following{/target}",  "gists_url": "https://api.github.com/gists{/gist_id}",  "hub_url": "https://api.github.com/hub",  ...}</code></pre></blockquote><p>上面的回应中，挑一个 URL 访问，又可以得到别的 URL。对于用户来说，不需要记住 URL 设计，只要从 api.github.com 一步步查找就可以了。</p><p>HATEOAS 的格式没有统一规定，上面例子中，GitHub 将它们与其他属性放在一起。更好的做法应该是，将相关链接与其他属性分开。</p><blockquote><pre class=" language-http"><code class="language-http"><span class="token response-status">HTTP/1.1 <span class="token property">200 OK</span></span><span class="token header-name keyword">Content-Type:</span> application/json<span class="token application/json"><span class="token punctuation">{</span>  <span class="token string">"status"</span><span class="token punctuation">:</span> <span class="token string">"In progress"</span><span class="token punctuation">,</span>   <span class="token string">"links"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">[</span>    <span class="token punctuation">{</span> <span class="token string">"rel"</span><span class="token punctuation">:</span><span class="token string">"cancel"</span><span class="token punctuation">,</span> <span class="token string">"method"</span><span class="token punctuation">:</span> <span class="token string">"delete"</span><span class="token punctuation">,</span> <span class="token string">"href"</span><span class="token punctuation">:</span><span class="token string">"/api/status/12345"</span> <span class="token punctuation">}</span> <span class="token punctuation">,</span>    <span class="token punctuation">{</span> <span class="token string">"rel"</span><span class="token punctuation">:</span><span class="token string">"edit"</span><span class="token punctuation">,</span> <span class="token string">"method"</span><span class="token punctuation">:</span> <span class="token string">"put"</span><span class="token punctuation">,</span> <span class="token string">"href"</span><span class="token punctuation">:</span><span class="token string">"/api/status/12345"</span> <span class="token punctuation">}</span>  <span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">}</span></span></code></pre></blockquote><h2 id="四、参考链接"><a href="#四、参考链接" class="headerlink" title="四、参考链接"></a>四、参考链接</h2><ul><li><a href="https://blog.florimondmanca.com/restful-api-design-13-best-practices-to-make-your-users-happy">RESTful API Design: 13 Best Practices to Make Your Users Happy</a>, by Florimond Manca</li><li><a href="https://docs.microsoft.com/en-us/azure/architecture/best-practices/api-design">API design</a>, by MicroSoft Azure</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> Restful API </tag>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表算法总结</title>
      <link href="/xyzhangblog/2020/12/21/bian-cheng-ji-chu/dong-tai-gui-hua-zong-jie/dong-tai-gui-hua/"/>
      <url>/xyzhangblog/2020/12/21/bian-cheng-ji-chu/dong-tai-gui-hua-zong-jie/dong-tai-gui-hua/</url>
      
        <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> Java </tag>
            
            <tag> 算法 </tag>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统（二）</title>
      <link href="/xyzhangblog/2020/12/09/ji-suan-ji-ji-chu/cao-zuo-xi-tong/cao-zuo-xi-tong-er/"/>
      <url>/xyzhangblog/2020/12/09/ji-suan-ji-ji-chu/cao-zuo-xi-tong/cao-zuo-xi-tong-er/</url>
      
        <content type="html"><![CDATA[<h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><h2 id="必要条件"><a href="#必要条件" class="headerlink" title="必要条件"></a>必要条件</h2><ul><li>互斥：资源只能分配给一个进程；</li><li>占有并等待：已经持有了某个资源的进程又去请求新资源；</li><li>不可抢占：只能由持有进程主动释放；</li><li>环路等待：有两个或两个以上进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源；</li></ul><h2 id="死锁解除"><a href="#死锁解除" class="headerlink" title="死锁解除"></a>死锁解除</h2><p>处理死锁应从破坏死锁出现的四个条件出发</p><ol><li>破坏互斥条件：例如打印机处理多线程抢占的情况时，真正请求物理打印机的进程只有打印机守护进程；</li><li>破坏占有和等待条件：<strong>资源预分配策略</strong>（所有进程在开始执行前请求所需要的全部资源）；</li><li>破坏不可抢占条件；</li><li>破坏环路等待：<strong>资源有序分配策略</strong>；</li></ol><h2 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h2><p>存在某种调度次序使得每个进程运行完毕</p><p>银行家算法</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树算法总结</title>
      <link href="/xyzhangblog/2020/11/24/bian-cheng-ji-chu/shu-zong-jie/er-cha-shu-suan-fa-zong-jie/"/>
      <url>/xyzhangblog/2020/11/24/bian-cheng-ji-chu/shu-zong-jie/er-cha-shu-suan-fa-zong-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="二叉树种类"><a href="#二叉树种类" class="headerlink" title="二叉树种类"></a>二叉树种类</h1><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> Java </tag>
            
            <tag> 算法 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表算法总结</title>
      <link href="/xyzhangblog/2020/11/24/bian-cheng-ji-chu/lian-biao-zong-jie/lian-biao-zong-jie/"/>
      <url>/xyzhangblog/2020/11/24/bian-cheng-ji-chu/lian-biao-zong-jie/lian-biao-zong-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="虚拟头节点"><a href="#虚拟头节点" class="headerlink" title="虚拟头节点"></a>虚拟头节点</h2><p>Solution203.移出链表元素</p><p>使用虚拟头节点避免每次遇到头节点删除等情况再做特殊处理</p><h2 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h2><p>Solution206.反转链表 </p><p><a href="https://leetcode-cn.com/problems/reverse-linked-list/">https://leetcode-cn.com/problems/reverse-linked-list/</a></p><p>迭代法：</p><p>反转链表的一部分</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> Java </tag>
            
            <tag> 算法 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法总结</title>
      <link href="/xyzhangblog/2020/11/20/bian-cheng-ji-chu/pai-xu-suan-fa-zong-jie/pai-xu-suan-fa-zong-jie/"/>
      <url>/xyzhangblog/2020/11/20/bian-cheng-ji-chu/pai-xu-suan-fa-zong-jie/pai-xu-suan-fa-zong-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="排序算法总结"><a href="#排序算法总结" class="headerlink" title="排序算法总结"></a>排序算法总结</h1><p>放一张小吴大佬的图，转自 <a href="https://www.cxyxiaowu.com/2026.html">https://www.cxyxiaowu.com/2026.html</a></p><img src="/xyzhangblog/2020/11/20/bian-cheng-ji-chu/pai-xu-suan-fa-zong-jie/pai-xu-suan-fa-zong-jie/AlgoSortCol.png" class="" title="总结"><p><strong>关于时间复杂度：</strong></p><ol><li>平方阶 O(n2) 排序 各类简单排序：直接插入、直接选择和冒泡排序。</li><li>线性对数阶 O(nlogn) 排序 快速排序、堆排序和归并排序；</li><li>O(n+§) 排序，§ 是介于 0 和 1 之间的常数。 希尔排序</li><li>线性阶 O(n) 排序 基数排序，此外还有桶、箱排序。</li></ol><p><strong>关于稳定性：</strong></p><ol><li>稳定的排序算法：冒泡排序（遇到相同值，让下一个值移动）、插入排序、归并排序（遇到相同值让左边的先拷贝）和基数排序。</li><li>不是稳定的排序算法：选择排序、快速排序、希尔排序、堆排序。</li></ol><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>归并排序基于分治思想，分治思想在递归上有三个步骤</p><ul><li>分解(Divide)：将n个元素分成两个含n/2的元素的子序列</li><li>解决(Conquer)：用合并排序法对两个子序列递归的排序</li><li>合并(Combine)：合并两个已排序的子序列得到排序结果</li></ul><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>平均时间复杂度：O(nlogn) // 无论元素在什么情况下都要做分割合并的步骤，开销的时间是不变的</p><p>最佳时间复杂度：O(nlogn)</p><p>最差时间复杂度：O(nlogn)</p><p>空间复杂度：O(n)</p><p>排序方式：外排序</p><p>稳定性：稳定</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">sortArray</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">mergeSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 归并排序</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>            mid <span class="token operator">=</span> <span class="token punctuation">(</span>left <span class="token operator">+</span> right<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token function">mergeSort</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> left<span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">mergeSort</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">merge</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> left<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> mid<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> lenleft <span class="token operator">=</span> mid<span class="token operator">-</span>left<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 包含mid和left因此需要+1</span>        <span class="token keyword">int</span> lenright <span class="token operator">=</span> right<span class="token operator">-</span>mid<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 申请新数组</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> leftArray <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>lenleft<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> rightArray <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>lenright<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 新数组赋值</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> lenleft<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            leftArray<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>left<span class="token operator">+</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> lenright<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            rightArray<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>mid<span class="token operator">+</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 从mid+1到right才是划分后的数组</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// merge</span>        <span class="token keyword">int</span> leftindex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> rightindex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>leftindex <span class="token operator">&lt;</span> lenleft <span class="token operator">&amp;&amp;</span> rightindex <span class="token operator">&lt;</span> lenright<span class="token punctuation">)</span>  <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>leftArray<span class="token punctuation">[</span>leftindex<span class="token punctuation">]</span> <span class="token operator">&lt;</span> rightArray<span class="token punctuation">[</span>rightindex<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                array<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">=</span> leftArray<span class="token punctuation">[</span>leftindex<span class="token punctuation">]</span><span class="token punctuation">;</span>                left<span class="token operator">++</span><span class="token punctuation">;</span>                leftindex<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                array<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">=</span> rightArray<span class="token punctuation">[</span>rightindex<span class="token punctuation">]</span><span class="token punctuation">;</span>                left<span class="token operator">++</span><span class="token punctuation">;</span>                rightindex<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>leftindex <span class="token operator">&lt;</span> lenleft<span class="token punctuation">)</span> <span class="token punctuation">{</span>            array<span class="token punctuation">[</span>left<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> leftArray<span class="token punctuation">[</span>leftindex<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>rightindex <span class="token operator">&lt;</span> lenright<span class="token punctuation">)</span> <span class="token punctuation">{</span>            array<span class="token punctuation">[</span>left<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> rightArray<span class="token punctuation">[</span>rightindex<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><p>参考资料：</p><p><a href="https://www.cnblogs.com/chengxiao/p/6194356.html">https://www.cnblogs.com/chengxiao/p/6194356.html</a></p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h3 id="基本思想-1"><a href="#基本思想-1" class="headerlink" title="基本思想"></a>基本思想</h3><p>分治：选择数组中某个数作为基数，通过一趟排序将要排序的数据分割成独立的两部分，其中一部分所有数都比基数小，另外一部分都比基数大，然后再按此方法对这两部分数据分别进行快排</p><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>平均时间复杂度：O(nlogn)</p><p>最佳时间复杂度：O(nlogn)</p><p>最差时间复杂度：O(n2) // 元素都分到一个子序列（序列本身为升序或降序排列）</p><p>空间复杂度：O(logn)</p><p>排序方式：内排序</p><p>稳定性：不稳定</p><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">sortArray</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> p <span class="token operator">=</span> <span class="token function">partition</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span>l<span class="token punctuation">,</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> l<span class="token punctuation">,</span> p<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> p<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">partition</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> pivot <span class="token operator">=</span> nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> l<span class="token punctuation">,</span> right <span class="token operator">=</span> r<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 从右向左找到第一个小于基数的数字停下</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">>=</span> pivot <span class="token operator">&amp;&amp;</span> left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>                right<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// 从左向右找到第一个大于基数的数字停下</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> pivot <span class="token operator">&amp;&amp;</span>  left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>                left<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 划分结束将基数值替换到中间位置 此时位于l的元素一定比基准值小（先从后向前遍历的原因）</span>        <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> left<span class="token punctuation">,</span> l<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> left<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> temp <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h3 id="优化方法"><a href="#优化方法" class="headerlink" title="优化方法"></a>优化方法</h3><ol><li><p>选择枢纽元</p><ul><li>选第一个或最后一个</li><li>随机选择</li><li>三数中值分割法</li></ul></li><li><p>分析重复元素处理</p></li><li><p>递归分成小数组时使用插入排序</p><p><strong>对于小数组（N&lt;=20）的输入序列，快速排序不如<a href="https://juejin.im/post/6844903821789888520">插入排序</a>；</strong>并且在我们上面的优化中，采用三数中值分割时，递归得到的结果可以是只有一个，或者两个元素，这时会有错误。所以，继续优化是将小的序列用插入排序代替，这会减少大约15%的运行时间。<strong>较好的截止范围是10</strong>（其实5-20产生的效果差不多）。</p></li></ol><p>选择插入一个是从已排序中找，一个是从未排序中找插入到已排序序列中</p><p>参考资料</p><p><a href="https://juejin.cn/post/6844903837749215246">https://juejin.cn/post/6844903837749215246</a></p><p><a href="https://zhuanlan.zhihu.com/p/57436476">https://zhuanlan.zhihu.com/p/57436476</a></p><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><h3 id="基本思想-2"><a href="#基本思想-2" class="headerlink" title="基本思想"></a>基本思想</h3><p>先在未排序序列中找到最小的将其交换到序列的初始位置，以后每次都再从未排序序列中找到最小的交换到已排序序列的末尾，此时每次从未排序序列中找到最小的就是已排序序列中最大的。</p><h3 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>平均时间复杂度：O(n2) // 每次都需要在剩余序列中选择最小的元素，与元素的初始排列无关</p><p>最佳时间复杂度：O(n2)</p><p>最差时间复杂度：O(n2)</p><p>空间复杂度：O(1)</p><p>排序方式：内排序</p><p>稳定性：不稳定</p><h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">// 选择排序</span>    <span class="token comment" spellcheck="true">// 遍历从未排序的序列中每次找到最小值，找到后与未排序序列第一个值交换</span>    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">selectSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> minValue<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> array<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            minValue <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> array<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>array<span class="token punctuation">[</span>minValue<span class="token punctuation">]</span> <span class="token operator">></span> array<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    minValue <span class="token operator">=</span> j<span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">int</span> temp <span class="token operator">=</span> array<span class="token punctuation">[</span>minValue<span class="token punctuation">]</span><span class="token punctuation">;</span>            array<span class="token punctuation">[</span>minValue<span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            array<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h3 id="基本思想-3"><a href="#基本思想-3" class="headerlink" title="基本思想"></a>基本思想</h3><p>将数据分为两部分，有序部分和无序部分，依次将无序元素插入到有序部分的特定位置，直到所有元素有序。</p><p>插入排序分为<strong>直接插入、二分插入、链表插入</strong>等。</p><p>Q：与<strong>选择排序</strong>的<strong>相同点</strong>？<br> A：当前索引左边的所有元素都是有序的，但它们的最终位置还不确定，为了给更小的元素腾出空间，它们可能会被移动。当索引到达数组的右端时，数组排序就完成了。</p><p>Q：与<strong>选择排序</strong>的<strong>不同点</strong>？<br> A：<strong>插入排序</strong>所需的时间取决于输入中元素的<strong>初始顺序</strong>。速度：元素已经有序（或接近有序）的数组 &gt; 随机顺序的数组</p><h3 id="复杂度分析-3"><a href="#复杂度分析-3" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>平均时间复杂度：O(n2)</p><p>最佳时间复杂度：O(n) // 元素本来就有序，只需要遍历一次即可。当倒置的数量很少时，比其他的排序算法都要快（对于部分有序的很有效）</p><p>最差时间复杂度：O(n2)</p><p>空间复杂度：O(1)</p><p>排序方式：内排序</p><p>稳定性：稳定</p><h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">// 插入排序</span>    <span class="token comment" spellcheck="true">// 依次向后遍历，每遇到一个元素就将其插入到数组的合适位置，其余元素向后移动</span>    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">insertSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> array<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> index <span class="token operator">=</span> i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>ans <span class="token operator">=</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>index <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> ans <span class="token operator">&lt;</span> array<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                array<span class="token punctuation">[</span>index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>                index<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            array<span class="token punctuation">[</span>index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> ans<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><h3 id="优化方法TODO"><a href="#优化方法TODO" class="headerlink" title="优化方法TODO"></a>优化方法TODO</h3><p>查找插入位置时使用二分查找方式</p><p>参考资料：</p><p><a href="https://www.jianshu.com/p/6d55ac4b72b4">https://www.jianshu.com/p/6d55ac4b72b4</a></p><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><h3 id="基本性质"><a href="#基本性质" class="headerlink" title="基本性质"></a>基本性质</h3><p>堆是一个数组，可以被看成是一个近似的完全二叉树，除最底层外该树完全充满（如下图）。树的根节点是A[1]，当给定一个节点下标i，可以很容易计算到它的父节点、左孩子右孩子的下标：</p><p>Parent(i) return i/2</p><p>Left(i) return 2i</p><p>Right(i) return 2i+1</p><img src="/xyzhangblog/2020/11/20/bian-cheng-ji-chu/pai-xu-suan-fa-zong-jie/pai-xu-suan-fa-zong-jie/%E5%A0%86.JPG" class=""><p><strong>这样做的优点是</strong>，将i值左移一位，Left过程可以在一条指令中计算出2i；将i值左移一位加一，Right过程可以快速计算得到2i+1；将i右移一位，Parent过程计算得i/2</p><p>堆排序中使用最大堆；优先级队列使用最小堆</p><p><strong>升序采用大顶堆，降序采用小顶堆</strong></p><h3 id="基本思想-4"><a href="#基本思想-4" class="headerlink" title="基本思想"></a>基本思想</h3><p>思想类似选择排序，每次通过堆结构选择出最小或最大值移动到末尾。结合了插入排序和归并排序的优点，时间复杂度O(nlogn)，与归并排序相同；具有空间原址性，与插入排序相同。</p><ol><li>将无序序列构建成堆，根据升序降序需求选择大顶堆或小顶堆；</li><li>将堆顶元素与末尾元素交换，将最大元素“沉”到数组末端；</li><li>重新调整结构，使其满足堆定义，继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序</li></ol><h3 id="复杂度分析-4"><a href="#复杂度分析-4" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>平均时间复杂度：O(nlogn)</p><p>最佳时间复杂度：O(nlogn)</p><p>最差时间复杂度：O(nlogn)</p><p>空间复杂度：O(1)</p><p>排序方式：内排序</p><p>稳定性：不稳定</p><h3 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h3><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">// 非递归实现</span>    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">heapSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 初始建堆</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> array<span class="token punctuation">.</span>length<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">heapAdjust</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> i<span class="token punctuation">,</span> array<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// n-1次选择排序</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> array<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 最后一个元素与第一个元素交换</span>            <span class="token keyword">int</span> temp <span class="token operator">=</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            array<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>            <span class="token function">heapAdjust</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 堆排序</span>    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">heapAdjust</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">,</span> <span class="token keyword">int</span> parent<span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> temp <span class="token operator">=</span> array<span class="token punctuation">[</span>parent<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// temp保存当前父节点</span>        <span class="token keyword">int</span> child <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> parent <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 先获得左孩子</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>child <span class="token operator">&lt;</span> len<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 如果有右孩子结点，并且右孩子结点的值大于左孩子结点，则选取右孩子结点</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>child <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> len <span class="token operator">&amp;&amp;</span> array<span class="token punctuation">[</span>child<span class="token punctuation">]</span> <span class="token operator">&lt;</span> array<span class="token punctuation">[</span>child<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                child<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// 如果父结点的值已经大于孩子结点的值，则直接结束</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>temp <span class="token operator">>=</span> array<span class="token punctuation">[</span>child<span class="token punctuation">]</span><span class="token punctuation">)</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 把孩子结点的值赋给父结点</span>            array<span class="token punctuation">[</span>parent<span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>child<span class="token punctuation">]</span><span class="token punctuation">;</span>            parent <span class="token operator">=</span> child<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// parent为temp真正存储的位置</span>            <span class="token comment" spellcheck="true">// 选取孩子结点的左孩子结点,继续向下筛选</span>            child <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> child <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        array<span class="token punctuation">[</span>parent<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>参考资料：</p><p><a href="https://www.cnblogs.com/jingmoxukong/p/4303826.html">https://www.cnblogs.com/jingmoxukong/p/4303826.html</a></p><p><a href="https://www.cnblogs.com/chengxiao/p/6129630.html">https://www.cnblogs.com/chengxiao/p/6129630.html</a></p><p>《算法导论》</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> Java </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java泛型详解</title>
      <link href="/xyzhangblog/2020/11/19/java/java-ji-chu/keng-java-fan-xing-xiang-jie/"/>
      <url>/xyzhangblog/2020/11/19/java/java-ji-chu/keng-java-fan-xing-xiang-jie/</url>
      
        <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> Java </tag>
            
            <tag> 泛型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工作中如何快速入手新项目</title>
      <link href="/xyzhangblog/2020/11/06/bian-cheng-xiang-guan-ji-zhu/ru-he-kuai-su-ru-shou-xin-xiang-mu/ru-he-kuai-su-ru-shou-xin-xiang-mu/"/>
      <url>/xyzhangblog/2020/11/06/bian-cheng-xiang-guan-ji-zhu/ru-he-kuai-su-ru-shou-xin-xiang-mu/ru-he-kuai-su-ru-shou-xin-xiang-mu/</url>
      
        <content type="html"><![CDATA[<blockquote><p>实习结束返校前，看到了一位同事写的公众号文章，文章主要讲解了一些工作上入手新项目的技巧，结合这段实习经历，自己也发现上手新项目的速度往往决定了你是否可以通过实习转正，因为从实习到转正最多也只有3个月的时间，上手项目的速度直接决定了你的工作产出；同时，在面试时也会有面试官着重考察这方面的能力，因此决定总结下与之相关的方式方法，无论是在面试还是今后工作上都能得以应用</p></blockquote><h2 id="接手新项目出现的问题"><a href="#接手新项目出现的问题" class="headerlink" title="接手新项目出现的问题"></a>接手新项目出现的问题</h2><p><strong>1.项目重点不明确</strong></p><p>一开始面对各种需求 ，很容易陷入工作细节里不可自拔，有时候跑偏了也不自知。或者做一些挠痒痒的工作，没有触及核心问题，效率非常低下。</p><p><strong>2.工具使用不熟练</strong></p><p>接手的新项目跟最近两年里做的项目很不同，使用的平台、工具也很不一样。熟悉这些平台工具的操作稍微需要花点儿时间。</p><p><strong>3.待看资料多而杂</strong></p><p>新接手的项目是从别的团队转过来的，已经积累了很长时间，因此有很多背景资料需要熟悉，包括产品说明文档、数据说明文档、各种平台使用说明等等。</p><p><strong>4.小需求应接不暇</strong></p><p>由于一开始对项目不熟悉，没有一个全局观，对项目各种数据的认识和理解也不是很深刻，一开始接数据的需求总处于一种被动的状态。因为没有全局观、缺乏规划，很多需求都是一次性的，非常耗时。</p><p><strong>5.未知问题的困扰</strong></p><p>新项目总是会遇到以前从来没有遇到、别人也没有经验的问题。如果时间紧急，就很容易陷入焦虑中。</p><h2 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h2><h3 id="做好项目管理跟进"><a href="#做好项目管理跟进" class="headerlink" title="做好项目管理跟进"></a>做好项目管理跟进</h3><p>这里说的项目管理是针对工作内容的项目管理</p><ul><li>具体做法：创建Excel表格，把项目中设计的所有数据分析相关的重点工作都列举出来，然后排期，每周跟进</li></ul><p>这样的好处是，保证自己在工作的大方向上不会跑偏，并且每周有个小目标压着，工作效率也会高一些。</p><p>另外，工作重点事项这里需要跟项目组的核心人员多交流，加深对项目的理解，然后紧紧围绕整个项目的KPI来确定自己的关键工作内容，为整个项目的KPI达成最大限度贡献自己的力量。</p><h3 id="构建工具百宝箱"><a href="#构建工具百宝箱" class="headerlink" title="构建工具百宝箱"></a>构建工具百宝箱</h3><p>针对工具不熟练，先使用二八法则，找到最常用的功能尽快上手。这个过程可以请教使用这个工具很熟练的老司机们，其他不常用的功能以后有空慢慢探索。</p><p>然后把最常用的功能、使用方法及账号密码记录在某个固定的地方。新项目涉及到的所有工具素材，我都会用同一个云笔记文件统一管理，然后收藏在浏览器最醒目的位置，每天开启工作的第一件事情就是打开这个收藏页保证能最快速调用工具开始干活。</p><h3 id="梳理材料并分类"><a href="#梳理材料并分类" class="headerlink" title="梳理材料并分类"></a>梳理材料并分类</h3><p>比如网页相关的，我会建在浏览器的一个收藏夹里，然后按照内容不同进行分类归档，保证用的时候可以快速找到。</p><p>文档资料，我也会根据内容进行分类归档。然后根据重要程度进行优先级排序，安排在日程里去看和理解。看的过程中，我会梳理重要信息，并记下自己的疑问与想法，然后找相关同事搞清楚。</p><p>这个步骤虽然很简单，整理起来也花不了多长时间，但是可以大大节约我的认知带宽，把省下来的意志力和时间花在更有价值的事情上。</p><h3 id="梳理需求统一规划"><a href="#梳理需求统一规划" class="headerlink" title="梳理需求统一规划"></a>梳理需求统一规划</h3><p>针对小需求应接不暇的问题，我的方法是：<strong>定期整理做过的数据需求，看看有没有什么共同点，找到共性，然后流程化run起来。</strong></p><p>但最终极的方法，还是要统一规划。但规划一般来自于对项目的深刻理解，一开始的琐碎小需求阶段正好可以为后期的规划提供素材。这么想了之后，我在前期做这些需求时也不会那么烦躁了。</p><p>最好的解决方案是，<strong>前期从琐碎小需求中积累经验，同时思考如何做整体规划。</strong>等经验积累的差不多时，整体规划也做得差不多了，然后一气呵成完成规划好的数据建设工作。最后，再用新的整体方案替换掉之前的临时方法，完美。</p><h3 id="拆解问题各个击破"><a href="#拆解问题各个击破" class="headerlink" title="拆解问题各个击破"></a>拆解问题各个击破</h3><p>针对项目中遇到的问题，<strong>我的方法是先去搜索有没有经验可以参考，使用谷歌搜索或者找有经验的同事问。</strong></p><p>如果都找不到，那就是一个真正的难题，这个时候我应该开心，因为如果解决了，我的工具百宝箱又可以添一笔资产了。</p><p>但一般情况下，这种场景是非常少的。真的遇上了，<strong>我最需要的可能就是一张纸、一支笔，然后找一个精力旺盛的安静时段，好好思考。</strong>有时一下子想不出来，就利用空闲时间的发散模式来帮助自己寻找灵感。大多数情况下，问题都会这样被解决掉。</p><p>另外一种工作的难题是隐蔽性的难题，看上去比较复杂和庞大。</p><p>但其实<strong>只要花时间思考下，这种问题是完全可以被拆解成多个小问题的，然后各个击破就好了。</strong></p><p>具体步骤是这样的，我会先找个精力好的时间段思考难题如何解决，这个阶段一般只需要拿一张白纸和笔就好了。</p><p>想好之后，<strong>我会针对这个难题专门建立一个Excel表来跟进。然后把拆解后的步骤记录下来，每个步骤都写上对应的方法、需要用到的资源以及可能的风险点，然后去跟进、执行，做完后记录状态。</strong></p><p>这样操作之后，尽管步骤可能会很多、很复杂，但因为我把所有的步骤记录在同一页文档上，就会形成一种全局观，并且我有记录跟进状态，所以一点也不乱。</p><p>拆解、记录真的是应对复杂问题的最好方法，每次遇到难题我都是用这个方法解决的，真是屡试不爽。</p><p>其实，很多时候难题只是看上去难而已，大脑一下子处理不了那么多层的信息。拆解和记录，其实相当于帮你节省大脑的计算资源，一次只专注一个核心问题，所以很容易就能解决。</p><p>参考资料：</p><p><a href="https://mp.weixin.qq.com/s/Z4sntS4H5IsUCeVwcJkVGA">https://mp.weixin.qq.com/s/Z4sntS4H5IsUCeVwcJkVGA</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 工作 </tag>
            
            <tag> 经验总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[GCD]使用dispatch_once实现单例</title>
      <link href="/xyzhangblog/2020/11/06/ios-kai-fa/gcd-shi-yong-dispatch-once-shi-xian-dan-li/gcd-shi-yong-dispatch-once-shi-xian-dan-li/"/>
      <url>/xyzhangblog/2020/11/06/ios-kai-fa/gcd-shi-yong-dispatch-once-shi-xian-dan-li/gcd-shi-yong-dispatch-once-shi-xian-dan-li/</url>
      
        <content type="html"><![CDATA[<h2 id="使用dispatch-once执行只需运行一次的线程安全代码"><a href="#使用dispatch-once执行只需运行一次的线程安全代码" class="headerlink" title="使用dispatch_once执行只需运行一次的线程安全代码"></a>使用dispatch_once执行只需运行一次的线程安全代码</h2><p>单例模式（singleton）对 Objective-C 开发者而言并不陌生，常见的实现方式为：在类编写名为<code>sharedInstance</code>的方法，该方法只会返回全类共用的单例实例，而不会在每次调用时都创建新的实例。假设有一个类叫<code>TestClass</code>，那么这个共享实例一般会这么写：</p><pre class=" language-objectivec"><code class="language-objectivec"><span class="token operator">+</span> <span class="token punctuation">(</span>id<span class="token punctuation">)</span>sharedInstance <span class="token punctuation">{</span>    <span class="token keyword">static</span> TestClass <span class="token operator">*</span>sharedInstance <span class="token operator">=</span> nil<span class="token punctuation">;</span>    <span class="token operator">@</span><span class="token function">synchronized</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>sharedInstance<span class="token punctuation">)</span> <span class="token punctuation">{</span>            sharedInstance <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token keyword">self</span> alloc<span class="token punctuation">]</span> init<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> sharedInstance<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>单例模式很容易引起激励讨论，Objective-C 的单例尤其如此。线程安全是大家争论的主要问题。为了保证线程安全，上述代码将创建单例实例的代码包裹在<strong>同步块</strong>里。无论是好是坏，反正这种实现方式很常用，这样的代码也随处可见。</p><p>不过，GCD 引入了一项特性，能使单例实现起来更加容易。所用的函数是：</p><pre class=" language-objectivec"><code class="language-objectivec"><span class="token keyword">void</span> <span class="token function">dispatch_once</span><span class="token punctuation">(</span>dispatch_once_t <span class="token operator">*</span>token<span class="token punctuation">,</span> dispatch_block_t block<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>此函数接受类型为<code>dispatch_once_t</code>的特殊参数，称其为<strong>标记</strong>（token），此外还接受 block 参数，对于给定 token 来说，该函数保证相关的 block 必定会执行，且仅执行一次。首次调用该函数时，必然会执行 block 的代码，最重要的一点在于，此操作完全是线程安全的。请注意，对于只需执行一次的块来说，每次调用函数时传入的 token 都必须是完全相同的。因此，开发者通常将标记变量声明在<code>static</code>或<code>global</code>作用域里。</p><p>上述实现单例模式所用的<code>sharedInstance</code>方法，可以用此函数来改写：</p><pre class=" language-objectivec"><code class="language-objectivec"><span class="token operator">+</span> <span class="token punctuation">(</span>id<span class="token punctuation">)</span>sharedInstance <span class="token punctuation">{</span>    <span class="token keyword">static</span> TestClass <span class="token operator">*</span>sharedInstance<span class="token punctuation">;</span>    <span class="token keyword">static</span> dispatch_once_t onceToken<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// typedef long dispatch_once_t;</span>    <span class="token function">dispatch_once</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>onceToken<span class="token punctuation">,</span> <span class="token operator">^</span><span class="token punctuation">{</span>        sharedInstance <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token keyword">self</span> alloc<span class="token punctuation">]</span> init<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> sharedInstance<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>使用<code>disptch_once</code>可以简化代码并且彻底保证线程安全，开发者根本无须担心加锁或同步。所有问题都由 GCD 在底层处理。由于每次调用时都必须使用完全相同的 token，所以 token 要声明成<code>static</code>。把该变量定义在<code>static</code>作用域中，可以保证编译器在每次执行<code>sharedInstance</code>方法时都会复用这个变量，而不会创建新变量。</p><p>此外，<code>dispatch_once</code>更高效。它没有使用重量级的同步机制，若是那样做的话，每次运行代码前都要获取锁，相反，此函数采用原子访问（atomic access）来查询标记，以判断其所对应的代码原来是否已经执行过。《Effective Objective-C 2.0》的作者在装有 64 位的 Mac OS X 10.8.2 系统的电脑上简单测试了性能，分别采用<code>@synchronized</code>方式及<code>dispatch_once</code>方式来实现<code>sharedInstance</code>，结果显示，后者的速度几乎是前者的 2 倍。</p><p>总结：</p><ol><li>经常需要编写<strong>只需执行一次的线程安全代码</strong>（thread-safe single-code execution），通过 GCD 提供的<code>dispatch_once</code>函数，很容易就能实现此功能。</li><li>token 应该声明在<code>static</code>或<code>global</code>中，这样的话，在把只需一次执行的块传给<code>dispatch_once</code>函数时，传进去的标记也是相同的。</li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://book.douban.com/subject/21370593/">Effective Objective-C 2.0</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> GCD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统（一）</title>
      <link href="/xyzhangblog/2020/10/25/ji-suan-ji-ji-chu/cao-zuo-xi-tong/cao-zuo-xi-tong-yi/"/>
      <url>/xyzhangblog/2020/10/25/ji-suan-ji-ji-chu/cao-zuo-xi-tong/cao-zuo-xi-tong-yi/</url>
      
        <content type="html"><![CDATA[<p><a href="https://mp.weixin.qq.com/s/i0PmP86iVv_-TlN8MLWIsw">https://mp.weixin.qq.com/s/i0PmP86iVv_-TlN8MLWIsw</a></p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="基本特征"><a href="#基本特征" class="headerlink" title="基本特征"></a>基本特征</h2><ol><li><p>并发</p><p>并发指宏观上一段时间内同时运行多个程序，并行指同一时刻能运行多个指令。操作系统使用进程和线程的概念实现程序的并发运行</p></li><li><p>共享</p><p>共享指系统中的资源可以被多个并发进程使用，分为互斥共享（临界资源，使用同步机制实现互斥访问）和同时共享</p></li><li><p>虚拟</p><p>虚拟指把一个物理实体转换为多个逻辑实体，分为时分复用（进程轮流占用处理器）、空分复用</p></li><li><p>异步</p></li></ol><h2 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h2><ol><li>进程管理</li><li>内存管理</li><li>文件管理</li><li>设备管理</li></ol><h1 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h1><h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><ol><li><p>进程</p><p>进程是资源分配的基本单位</p></li><li><p>线程</p><p>线程是独立调度的基本单位，一个进程中可以有多个线程，共享进程资源</p></li><li><p><strong>进程与线程的区别</strong></p><p>对于操作系统而言,进程偏重于内存资源管理,线程偏重于CPU调度</p><ul><li><p>拥有资源</p><p>进程拥有资源，线程不拥有资源，但可以访问隶属于进程的资源</p></li><li><p>调度</p><p>线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程的切换，开销小速度快；从一个进程中的线程切换到另一个进程中的线程会引起进程切换</p></li><li><p>系统开销</p><p>创建或销毁进程时，操作系统需要为其分配或回收资源（内存空间、IO等），切换进程时，操作系统也需要将这些资源更新，开销较大；</p><p>线程切换只需保存设置少量内容（<strong>堆栈、少量寄存器、程序计数器PC</strong>），开销很小。</p></li><li><p>通信方面</p><p>线程间通信可以通过读写同一进程中的数据，进程通信需要借助IPC</p></li></ul></li></ol><h2 id="进程状态切换"><a href="#进程状态切换" class="headerlink" title="进程状态切换"></a>进程状态切换</h2><ul><li>就绪状态（Ready）：等待被调度</li><li>运行状态（running）</li><li>阻塞状态（waiting）：缺少某些必要的资源</li></ul><h2 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h2><h3 id="批处理系统-保证吞吐量和周转时间"><a href="#批处理系统-保证吞吐量和周转时间" class="headerlink" title="批处理系统-保证吞吐量和周转时间"></a>批处理系统-保证吞吐量和周转时间</h3><ol><li>先来先服务（FCFS）</li><li>短作业优先（SJF）</li><li>最短剩余时间优先（SRTN）</li></ol><h3 id="交互式系统–快速响应"><a href="#交互式系统–快速响应" class="headerlink" title="交互式系统–快速响应"></a>交互式系统–快速响应</h3><ol><li>时间片轮转</li><li>优先级调度</li><li>多级反馈队列</li></ol><h3 id="实时系统-截止时间前响应"><a href="#实时系统-截止时间前响应" class="headerlink" title="实时系统-截止时间前响应"></a>实时系统-截止时间前响应</h3><h2 id="线程同步的方法✨"><a href="#线程同步的方法✨" class="headerlink" title="线程同步的方法✨"></a>线程同步的方法✨</h2><p>临界区、互斥量主要用于互斥控制；信号量、事件对象主要用于同步控制</p><h3 id="1-临界区"><a href="#1-临界区" class="headerlink" title="1. 临界区"></a>1. 临界区</h3><p>通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。在任何时刻只允许一个线程对共享资源访问，当一个线程访问后其他试图访问的线程被挂起，直到公共资源被释放</p><h3 id="2-互斥量Mutex"><a href="#2-互斥量Mutex" class="headerlink" title="2. 互斥量Mutex"></a>2. 互斥量Mutex</h3><p>只有拥有互斥量的线程才有访问公共资源的权限。互斥量只有一个，当前拥有互斥量的线程处理完任务后必须将线程交出，以便其他线程访问该资源。</p><h3 id="3-信号量"><a href="#3-信号量" class="headerlink" title="3. 信号量"></a>3. <a href="https://chorer.github.io/2020/03/25/OS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5%EF%BC%9A%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6/">信号量</a></h3><p>允许多个线程在同一时刻访问同一资源</p><h3 id="4-事件对象"><a href="#4-事件对象" class="headerlink" title="4. 事件对象"></a>4. 事件对象</h3><p>通过通知操作的方式来保持线程的同步，还可以方便实现对多个线程的优先级比较的操作</p><h2 id="进程通信的方法✨"><a href="#进程通信的方法✨" class="headerlink" title="进程通信的方法✨"></a>进程通信的方法✨</h2><ul><li>进程同步:控制多个进程按一定顺序执行;</li><li>进程通信:进程间传输信息、资源共享、时间通    知、进程控制</li></ul><p>个人认为同步与通信概念上没必要分的特别细，进程通信是一种手段，同步是一种目的．能够通信就是一定是一种同步机制．</p><h3 id="1-匿名管道"><a href="#1-匿名管道" class="headerlink" title="1. 匿名管道"></a>1. 匿名管道</h3><p>IPC最 基本的一种实现机制，基于字节流通信，本质上就是实现一个两进程都能访问的文件，若想要数据流从父进程流向子进程，则关闭父进程的读端（fd[0]）与子进程的写端（fd[1]）；</p><ul><li><p>只能半双工通信(使用pipe函数创建,fd[0]用于读,fd[1]用于写);</p></li><li><p>只能在父子进程或兄弟进程中使用;</p></li></ul><h3 id="2-命名管道-FIFO"><a href="#2-命名管道-FIFO" class="headerlink" title="2. 命名管道(FIFO)"></a>2. 命名管道(FIFO)</h3><p>FIFO常用于C-S应用程序中，FIFO用作汇聚点在客户进程和服务器进程之间传递数据</p><ul><li><p>任意进程间半双工通信，可以在父子进程中使用（使用mkfifo函数创建）</p></li><li><p>命名管道使用前需要使用open()打开，命名管道是设备文件存储在磁盘上，匿名管道是存在于内存中的特殊文件。</p><p>命名管道使用open打开有可能会被阻塞：以读写方式打开一定不会阻塞；以只读方式打开，调用open()函数会被阻塞直到有数据可读；以只写方式打开，调用open函数会被阻塞直到以其他方式打开。</p></li></ul><h3 id="3-消息队列"><a href="#3-消息队列" class="headerlink" title="3. 消息队列"></a>3. 消息队列</h3><p>实现两进程间双向通信，克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</p><ul><li>可独立于读写进程存在</li><li>避免FIFO的同步阻塞问题，不需要进程自己提供同步方法</li><li>读消息时可以根据消息类型有选择性的接收消息，而不像FIFO只能默认接收</li></ul><h3 id="4-信号量（semophore）"><a href="#4-信号量（semophore）" class="headerlink" title="4. 信号量（semophore）"></a>4. 信号量（semophore）</h3><p>计数器，用于为多个进程提供对共享数据对象的访问。作为一种锁机制，防止某些进程正在访问共享资源时其他进程也访问。</p><h3 id="5-信号（signal）"><a href="#5-信号（signal）" class="headerlink" title="5. 信号（signal）"></a>5. 信号（signal）</h3><p>进程间传递信号，捕获到信号后执行对应绑定的代码，可以实现进程通信的“单播”“广播”</p><h3 id="6-共享内存"><a href="#6-共享内存" class="headerlink" title="6. 共享内存"></a>6. 共享内存</h3><p>允许多个进程共享一个给定的存储区，不需要在进程间复制数据，速度最快；</p><p>需要使用信号量进行访问的同步</p><h3 id="7-Socket套接字"><a href="#7-Socket套接字" class="headerlink" title="7. Socket套接字"></a>7. Socket套接字</h3><p>可用于网络上不同机器间的进程通信</p><h1 id="TODO："><a href="#TODO：" class="headerlink" title="TODO："></a>TODO：</h1><p>经典同步问题：哲学家进餐、读者写者问题、生产者消费者问题</p><p>参考资料</p><p><a href="https://blog.csdn.net/weixin_39763552/article/details/80306734">进程间通信（IPC）——匿名管道和命名管道</a></p><p><a href="https://cloud.tencent.com/developer/article/1129585">进程同步和线程同步概述</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码编译时都做了什么？</title>
      <link href="/xyzhangblog/2020/10/20/ji-suan-ji-ji-chu/bian-yi-yuan-li/dai-ma-bian-yi-shi-du-zuo-liao-shi-me/dai-ma-bian-yi-shi-du-zuo-liao-shi-me/"/>
      <url>/xyzhangblog/2020/10/20/ji-suan-ji-ji-chu/bian-yi-yuan-li/dai-ma-bian-yi-shi-du-zuo-liao-shi-me/dai-ma-bian-yi-shi-du-zuo-liao-shi-me/</url>
      
        <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 编译原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>提升hexo博客写作效率</title>
      <link href="/xyzhangblog/2020/10/18/bian-cheng-xiang-guan-ji-zhu/ti-sheng-hexo-bo-ke-xie-zuo-xiao-lu/ti-sheng-hexo-bo-ke-xie-zuo-xiao-lu/"/>
      <url>/xyzhangblog/2020/10/18/bian-cheng-xiang-guan-ji-zhu/ti-sheng-hexo-bo-ke-xie-zuo-xiao-lu/ti-sheng-hexo-bo-ke-xie-zuo-xiao-lu/</url>
      
        <content type="html"><![CDATA[<ol><li>新建文章</li></ol><pre class=" language-bash"><code class="language-bash">hexo new post <span class="token string">"文章标题"</span></code></pre><p>为保证目录结构清晰易于查找，建议将生成的markdown文件放置在文件夹下<br>**<u>若有插入图片的需求需要在markdown文件的同级目录下新建同名文件夹，用于存储图片，文章中使用相对路径进行图片的引用（参考<a href="https://github.com/1170300514/xyzhangblog/tree/master/source/_posts/IoT/TencentOSTiny%E7%94%B2%E9%86%9B%E4%BC%A0%E6%84%9F%E5%99%A8">甲醛传感器</a>文章的路径设置方式）</u>**</p><ol start="2"><li><p>在文章头信息中添加summary字段用于首页展示，相当于次级标题</p><p>文章头信息有很多可配字段 详细如下：</p><p><code>Front-matter</code> 选项中的所有内容均为<strong>非必填</strong>的。但我仍然建议至少填写 <code>title</code> 和 <code>date</code> 的值。</p><table><thead><tr><th>配置选项</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>title</td><td><code>Markdown</code> 的文件标题</td><td>文章标题，强烈建议填写此选项</td></tr><tr><td>date</td><td>文件创建时的日期时间</td><td>发布时间，强烈建议填写此选项，且最好保证全局唯一</td></tr><tr><td>author</td><td>根 <code>_config.yml</code> 中的 <code>author</code></td><td>文章作者</td></tr><tr><td>img</td><td><code>featureImages</code> 中的某个值</td><td>文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如: <code>http://xxx.com/xxx.jpg</code></td></tr><tr><td>top</td><td><code>true</code></td><td>推荐文章（文章是否置顶），如果 <code>top</code> 值为 <code>true</code>，则会作为首页推荐文章</td></tr><tr><td>cover</td><td><code>false</code></td><td><code>v1.0.2</code>版本新增，表示该文章是否需要加入到首页轮播封面中</td></tr><tr><td>coverImg</td><td>无</td><td><code>v1.0.2</code>版本新增，表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片</td></tr><tr><td>password</td><td>无</td><td>文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 <code>password</code> 的值，该值必须是用 <code>SHA256</code> 加密后的密码，防止被他人识破。前提是在主题的 <code>config.yml</code> 中激活了 <code>verifyPassword</code> 选项</td></tr><tr><td>toc</td><td><code>true</code></td><td>是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 <code>config.yml</code> 中激活了 <code>toc</code> 选项</td></tr><tr><td>mathjax</td><td><code>false</code></td><td>是否开启数学公式支持 ，本文章是否开启 <code>mathjax</code>，且需要在主题的 <code>_config.yml</code> 文件中也需要开启才行</td></tr><tr><td>summary</td><td>无</td><td>文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要</td></tr><tr><td>categories</td><td>无</td><td>文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类</td></tr><tr><td>tags</td><td>无</td><td>文章标签，一篇文章可以多个标签</td></tr><tr><td>keywords</td><td>文章标题</td><td>文章关键字，SEO 时需要</td></tr><tr><td>reprintPolicy</td><td>cc_by</td><td>文章转载规则， 可以是 cc_by, cc_by_nd, cc_by_sa, cc_by_nc, cc_by_nc_nd, cc_by_nc_sa, cc0, noreprint 或 pay 中的一个</td></tr></tbody></table><p>以下为文章的 <code>Front-matter</code> 示例。</p><h3 id="最简示例"><a href="#最简示例" class="headerlink" title="最简示例"></a>最简示例</h3><pre><code>---title: typora-vue-theme主题介绍date: 2018-09-07 09:25:00---</code></pre><h3 id="最全示例"><a href="#最全示例" class="headerlink" title="最全示例"></a>最全示例</h3><pre><code>---title: typora-vue-theme主题介绍date: 2018-09-07 09:25:00author: 赵奇img: /source/images/xxx.jpgtop: truecover: truecoverImg: /images/1.jpgpassword: 8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92toc: falsemathjax: falsesummary: 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要categories: Markdowntags:  - Typora  - Markdown---</code></pre></li><li><p>文章内容撰写完成后使用hexo命令在本地运行</p><pre class=" language-bash"><code class="language-bash">hexo cleanhexo generatehexo server</code></pre><p>查看无误后push到github触发CI生成网页</p></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git强制拉取与推送</title>
      <link href="/xyzhangblog/2020/10/18/git/git-qiang-zhi-la-qu-yu-tui-song/git-qiang-zhi-la-qu-yu-tui-song/"/>
      <url>/xyzhangblog/2020/10/18/git/git-qiang-zhi-la-qu-yu-tui-song/git-qiang-zhi-la-qu-yu-tui-song/</url>
      
        <content type="html"><![CDATA[<h2 id="Git强制拉取"><a href="#Git强制拉取" class="headerlink" title="Git强制拉取"></a>Git强制拉取</h2><p>有时本地修改代码出现异常，需要将本地修改全部忽略，强制拉取远端</p><pre class=" language-bash"><code class="language-bash">// 方法1: 清空本地修改后 拉取远端代码<span class="token function">git</span> reset --hard<span class="token function">git</span> pull// 方法2: 直接拉取远端代码将HEAD指向master最新版本<span class="token function">git</span> fetch --all<span class="token function">git</span> reset --hard origin/master<span class="token function">git</span> pull</code></pre><h2 id="Git强制推送"><a href="#Git强制推送" class="headerlink" title="Git强制推送"></a>Git强制推送</h2><p>强制用本地代码覆盖远程仓库</p><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> push -f origin master</code></pre><h2 id="Git撤销commit"><a href="#Git撤销commit" class="headerlink" title="Git撤销commit"></a>Git撤销commit</h2><p>执行完commit后，想撤回commit，以下命令可以仅撤回commit不删除代码</p><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> reset --soft HEAD^</code></pre><h4 id="回滚次数"><a href="#回滚次数" class="headerlink" title="回滚次数"></a>回滚次数</h4><p>HEAD^的意思是上一个版本，也可以写成HEAD~1</p><p>如果你进行了2次commit，想都撤回，可以使用HEAD~2</p><h4 id="参数含义"><a href="#参数含义" class="headerlink" title="参数含义"></a>参数含义</h4><ol><li><p>–mixed </p><p>意思是：不删除工作空间改动代码，撤销commit，并且撤销git add . 操作</p><p>这个为默认参数,git reset –mixed HEAD^ 和 git reset HEAD^ 效果是一样的。</p></li><li><p>–soft </p><p>不删除工作空间改动代码，撤销commit，不撤销git add . </p></li><li><p>–hard</p><p>删除工作空间改动代码，撤销commit，撤销git add . </p><p>注意完成这个操作后，就恢复到了上一次的commit状态。</p></li></ol><h4 id="仅修改commit注释"><a href="#仅修改commit注释" class="headerlink" title="仅修改commit注释"></a>仅修改commit注释</h4><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> commit --amend</code></pre><p>此时会进入默认vim编辑器，修改注释完毕后保存就好了。</p><p>TODO: 解决git冲突</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ProtoBuf使用总结</title>
      <link href="/xyzhangblog/2020/10/17/bian-cheng-xiang-guan-ji-zhu/protobuf-shi-yong/protobuf-shi-yong/"/>
      <url>/xyzhangblog/2020/10/17/bian-cheng-xiang-guan-ji-zhu/protobuf-shi-yong/protobuf-shi-yong/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-序列化"><a href="#0x00-序列化" class="headerlink" title="0x00 序列化"></a>0x00 序列化</h2><p><strong>序列化是指将数据结构或者对象的状态转换成可存储（文件/内存）、可传输的格式</strong> 反之从存储或传输形式转换为数据结构或对象的形式成为反序列化</p><p>常见的序列化格式有：XML、JSON、YAML、plist…</p><h2 id="0x01-Protocol-Buffers简介"><a href="#0x01-Protocol-Buffers简介" class="headerlink" title="0x01 Protocol Buffers简介"></a>0x01 Protocol Buffers简介</h2><blockquote><p>ProtoBuf：google推出的语言中立，平台无关，可扩展的序列化数据的格式，可用于通信协议，数据存储等；相比XML更小巧、快速、简单。一旦定义要处理的数据的数据结构后，就可以利用ProtoBuf的代码生成工具生成相关代码。只需使用Protobuf对数据结构进行一次描述，就可以利用不同语言或从不同数据流中对结构化数据进行读写。</p></blockquote><p>Protocol buffers适合做数据存储或RPC数据交换格式。可用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化结构数据格式。Protocol buffers包含序列化格式的定义、对应语言的库和IDL编译器，正常情况下需要定义proto文件，然后使用IDL编译器编译成需要的语言。</p><p><strong>protocol buffers 诞生之初是为了解决服务器端新旧协议(高低版本)兼容性问题，名字也很体贴，“协议缓冲区”。只不过后期慢慢发展成用于传输数据</strong>。</p><h2 id="0x02-Protocol-Buffers的特点及用法"><a href="#0x02-Protocol-Buffers的特点及用法" class="headerlink" title="0x02 Protocol Buffers的特点及用法"></a>0x02 Protocol Buffers的特点及用法</h2><h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><ul><li>便捷引入新字段，且无需了解所有字段服务器即可进行数据的解析和传递</li><li>数据格式更具自我描述性</li><li>序列化与反序列化代码可以自动生成，避免手动解析</li></ul><h3 id="用法："><a href="#用法：" class="headerlink" title="用法："></a>用法：</h3><p>proto中所有结构化数据都被称为<code>message</code></p><pre class=" language-proto"><code class="language-proto">syntax = "proto3";message SearchRequest {  string query = 1;  int32 page_number = 2;  int32 result_per_page = 3;}</code></pre><h3 id="1-分配字段编号"><a href="#1-分配字段编号" class="headerlink" title="1. 分配字段编号"></a>1. 分配字段编号</h3><p>每个消息定义中的每个字段都有<strong>唯一的编号</strong>。这些字段编号用于标识消息二进制格式中的字段，并且在使用消息类型后不应更改。请注意，范围 1 到 15 中的字段编号需要一个字节进行编码，包括字段编号和字段类型。范围 16 至 2047 中的字段编号需要两个字节。所以你应该保留数字 1 到 15 作为非常频繁出现的消息元素。请记住为将来可能添加的频繁出现的元素留出一些空间。</p><p>可以指定的最小字段编号为1，最大字段编号为2^29^-1 或 536,870,911。也不能使用数字 19000 到 19999（FieldDescriptor :: kFirstReservedNumber 到 FieldDescriptor :: kLastReservedNumber），因为它们是为 Protocol Buffers实现保留的。</p><p>如果在 .proto 中使用这些保留数字中的一个，Protocol Buffers 编译的时候会报错。</p><p>同样，您不能使用任何以前 Protocol Buffers 保留的一些字段号码。保留字段是什么，下一节详细说明。</p><h3 id="2-保留字段"><a href="#2-保留字段" class="headerlink" title="2. 保留字段"></a>2. 保留字段</h3><p>如果您通过完全删除某个字段或将其注释掉来更新消息类型，那么未来的用户可以在对该类型进行自己的更新时重新使用该字段号。如果稍后加载到了的旧版本 <code>.proto</code> 文件，则会导致服务器出现严重问题，例如数据混乱，隐私错误等等。确保这种情况不会发生的一种方法是指定删除字段的字段编号（或名称，这也可能会导致 JSON 序列化问题）为 <code>reserved</code>。如果将来的任何用户试图使用这些字段标识符，Protocol Buffers 编译器将会报错。</p><pre class=" language-proto"><code class="language-proto">message Foo {  reserved 2, 15, 9 to 11;  reserved "foo", "bar";}</code></pre><p><strong>注意，不能在同一个 <code>reserved</code> 语句中混合字段名称和字段编号</strong>。如有需要需要像上面这个例子这样写。</p><h3 id="3-默认字段规则"><a href="#3-默认字段规则" class="headerlink" title="3. 默认字段规则"></a>3. 默认字段规则</h3><ul><li>字段名不能重复，必须唯一。</li><li>repeated 字段：可以在一个 message 中重复任何数字多次(包括 0 )，不过这些重复值的顺序被保留。</li></ul><h2 id="0x03-Protocol-Buffers的优缺点"><a href="#0x03-Protocol-Buffers的优缺点" class="headerlink" title="0x03 Protocol Buffers的优缺点"></a>0x03 Protocol Buffers的优缺点</h2><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ul><li>简单</li><li>数据体积小</li><li>反序列化速度快</li><li>自动化生成易于编码方式使用的数据访问类</li></ul><h4 id="举个例子："><a href="#举个例子：" class="headerlink" title="举个例子："></a>举个例子：</h4><p>如果要编码一个用户的名字和 email 信息，用 XML 的方式如下：</p><pre class=" language-xml"><code class="language-xml">  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>person</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>John Doe<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>email</span><span class="token punctuation">></span></span>jdoe@example.com<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>email</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>person</span><span class="token punctuation">></span></span></code></pre><p>相同需求，如果换成 protocol buffers 来实现，定义文件如下：</p><pre class=" language-c"><code class="language-c"><span class="token macro property"># Textual representation of a protocol buffer.</span><span class="token macro property"># This is *not* the binary format used on the wire.</span>person <span class="token punctuation">{</span>  name<span class="token punctuation">:</span> <span class="token string">"John Doe"</span>  email<span class="token punctuation">:</span> <span class="token string">"jdoe@example.com"</span><span class="token punctuation">}</span></code></pre><p>protocol buffers 通过编码以后，以二进制的方式进行数据传输，最多只需要 28 bytes 空间和 100-200 ns 的反序列化时间。但是 XML 则至少需要 69 bytes 空间（经过压缩以后，去掉所有空格）和 5000-10000 的反序列化时间。</p><p>上面说的是性能方面的优势。接下来说说编码方面的优势。</p><p>protocol buffers 自带代码生成工具，可以生成友好的数据访问存储接口。从而开发人员使用它来编码更加方便。例如上面的例子，如果用 C++ 的方式去读取用户的名字和 email，直接调用对应的 get 方法即可（所有属性的 get 和 set 方法的代码都自动生成好了，只需要调用即可）</p><pre class=" language-c"><code class="language-c">  cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Name: "</span> <span class="token operator">&lt;&lt;</span> person<span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>  cout <span class="token operator">&lt;&lt;</span> <span class="token string">"E-mail: "</span> <span class="token operator">&lt;&lt;</span> person<span class="token punctuation">.</span><span class="token function">email</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></code></pre><p>而 XML 读取数据会麻烦一些：</p><pre class=" language-xml"><code class="language-xml">  cout &lt;&lt; "Name: "       &lt;&lt; person.getElementsByTagName("name")->item(0)->innerText()       &lt;&lt; endl;  cout &lt;&lt; "E-mail: "       &lt;&lt; person.getElementsByTagName("email")->item(0)->innerText()       &lt;&lt; endl;</code></pre><p>Protobuf 语义更清晰，无需类似 XML 解析器的东西（因为 Protobuf 编译器会将 .proto 文件编译生成对应的数据访问类以对 Protobuf 数据进行序列化、反序列化操作）。</p><p>使用 Protobuf 无需学习复杂的文档对象模型，Protobuf 的编程模式比较友好，简单易学，同时它拥有良好的文档和示例，对于喜欢简单事物的人们而言，Protobuf 比其他的技术更加有吸引力。</p><p>protocol buffers 最后一个非常棒的特性是，即“向后”兼容性好，人们不必破坏已部署的、依靠“老”数据格式的程序就可以对数据结构进行升级。这样您的程序就可以不必担心因为消息结构的改变而造成的大规模的代码重构或者迁移的问题。因为添加新的消息中的 field 并不会引起已经发布的程序的任何改变(因为存储方式本来就是无序的，k-v 形式)。</p><p>当然 protocol buffers 也并不是完美的，在使用上存在一些局限性。</p><p>由于文本并不适合用来描述数据结构，所以 Protobuf 也不适合用来对基于文本的标记文档（如 HTML）建模。另外，由于 XML 具有某种程度上的自解释性，它可以被人直接读取编辑，在这一点上 Protobuf 不行，它以二进制的方式存储，除非你有 <code>.proto</code> 定义，否则你没法直接读出 Protobuf 的任何内容。</p><h2 id="0x04-参考资料："><a href="#0x04-参考资料：" class="headerlink" title="0x04 参考资料："></a>0x04 参考资料：</h2><p>pb的编码原理、更详细的用法分析：<a href="https://halfrost.com/protobuf_encode/">https://halfrost.com/protobuf_encode/</a></p><p>pb的性能分析参考：<a href="https://halfrost.com/protobuf_decode/#toc-13">https://halfrost.com/protobuf_decode/#toc-13</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> ProtoBuf </tag>
            
            <tag> 序列化 </tag>
            
            <tag> 反序列化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32+TencentOSTiny实现甲醛传感器</title>
      <link href="/xyzhangblog/2020/10/01/iot/tencentostiny-jia-quan-chuan-gan-qi/tencentostiny-ti-yan/"/>
      <url>/xyzhangblog/2020/10/01/iot/tencentostiny-jia-quan-chuan-gan-qi/tencentostiny-ti-yan/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-环境说明"><a href="#0x00-环境说明" class="headerlink" title="0x00. 环境说明"></a>0x00. 环境说明</h2><ul><li>软件环境：win10 64位 + MDK</li><li>开发板：TOS_EVB_G0开发板 x 1</li><li>传感器：英国 Dart 甲醛传感器 x 1</li><li>扩展板：E53甲醛传感器底板 x 1</li><li>下载器：ST-Link下载器 x 1</li></ul><h2 id="0x01-安装基础工具（硬件）"><a href="#0x01-安装基础工具（硬件）" class="headerlink" title="0x01. 安装基础工具（硬件）"></a>0x01. 安装基础工具（硬件）</h2><h4 id="连接ST-Link与开发板，严格按照如下方式进行连接否则可能烧坏MCU"><a href="#连接ST-Link与开发板，严格按照如下方式进行连接否则可能烧坏MCU" class="headerlink" title="连接ST-Link与开发板，严格按照如下方式进行连接否则可能烧坏MCU"></a>连接ST-Link与开发板，严格按照如下方式进行连接否则可能烧坏MCU</h4><p>开发板3v3—&gt; STlink 3.3V<br>开发板DIO—&gt; STlink SWDIO<br>开发板CLK—&gt; STlink SWCLK<br>开发板GND—&gt; STlink GND</p><h4 id="设置跳线帽，切换boot选择端子和串口选择端子"><a href="#设置跳线帽，切换boot选择端子和串口选择端子" class="headerlink" title="设置跳线帽，切换boot选择端子和串口选择端子"></a>设置跳线帽，切换boot选择端子和串口选择端子</h4><ol><li>开发版上的ESP固件下载配置切换到GND，使wifi处于下载模式</li><li>Boot选择切换到0</li><li>串口切换端子置于中间，使ESP8266直接与PC串口连接</li></ol><p>设置完成后的结果如下图所示：</p><img src="/xyzhangblog/2020/10/01/iot/tencentostiny-jia-quan-chuan-gan-qi/tencentostiny-ti-yan/%E7%AB%AF%E5%AD%90%E8%AE%BE%E7%BD%AE.jpg" class="" title="端子设置"><h2 id="0x02-安装基础工具（软件）"><a href="#0x02-安装基础工具（软件）" class="headerlink" title="0x02. 安装基础工具（软件）"></a>0x02. 安装基础工具（软件）</h2><h4 id="安装MDK软件"><a href="#安装MDK软件" class="headerlink" title="安装MDK软件"></a>安装MDK软件</h4><ul><li><p>激活软件，导入License，注意这部需要以管理员身份运行</p></li><li><p>安装单片机型号中对应的Pack</p><p>可以直接在MDK软件上在线安装，在导航栏打开Pack安装页面，找到STM32G0xx，点击install安装</p><img src="/xyzhangblog/2020/10/01/iot/tencentostiny-jia-quan-chuan-gan-qi/tencentostiny-ti-yan/image-20201001164941942.png" class="" title="image-20201001164941942"></li></ul><h4 id="安装ST-Link驱动"><a href="#安装ST-Link驱动" class="headerlink" title="安装ST-Link驱动"></a>安装ST-Link驱动</h4><p>前往ST官网即可下载：</p><p><a href="https://www.st.com/content/st_com/zh/products/development-tools/software-development-tools/stm32-software-development-tools/stm32-utilities/stsw-link009.html">https://www.st.com/content/st_com/zh/products/development-tools/software-development-tools/stm32-software-development-tools/stm32-utilities/stsw-link009.html</a></p><p>安装完成后打开设备管理器，查看通用串行总线设备，出现如下所示，则驱动安装成功</p><img src="/xyzhangblog/2020/10/01/iot/tencentostiny-jia-quan-chuan-gan-qi/tencentostiny-ti-yan/image-20201001165811036.png" class="" title="image-20201001165811036"><h4 id="CH340串口驱动安装"><a href="#CH340串口驱动安装" class="headerlink" title="CH340串口驱动安装"></a>CH340串口驱动安装</h4><p>直接通过互联网搜索CH340串口芯片的驱动进行下载安装即可</p><img src="/xyzhangblog/2020/10/01/iot/tencentostiny-jia-quan-chuan-gan-qi/tencentostiny-ti-yan/image-20201001163019855.png" class="" title="image-20201001163019855"><h4 id="安装串口调试助手"><a href="#安装串口调试助手" class="headerlink" title="安装串口调试助手"></a>安装串口调试助手</h4><p>工具下载：<a href="http://www.daxia.com/download/sscom.rar">http://www.daxia.com/download/sscom.rar</a></p><img src="/xyzhangblog/2020/10/01/iot/tencentostiny-jia-quan-chuan-gan-qi/tencentostiny-ti-yan/image-20201001164049729.png" class="" title="image-20201001164049729"><p>根据PC和终端之间的连接选择正确的串行端口。</p><p>打开设备管理器，在端口列表（如果没有端口选项需要在“查看”中选取“显示隐藏的设备”）中可以看到连接所使用的端口号</p><p><del>这里遇到一个非常蠢的问题：STLink和USB需要同时连接到板子上，否则就会出现电脑不识别CH340设备的现象</del></p><img src="/xyzhangblog/2020/10/01/iot/tencentostiny-jia-quan-chuan-gan-qi/tencentostiny-ti-yan/image-20201001172758481.png" class="" title="image-20201001172758481"><h2 id="0x03-烧写腾讯云定制固件"><a href="#0x03-烧写腾讯云定制固件" class="headerlink" title="0x03. 烧写腾讯云定制固件"></a>0x03. 烧写腾讯云定制固件</h2><h4 id="下载固件"><a href="#下载固件" class="headerlink" title="下载固件"></a>下载固件</h4><p>下载链接：<a href="https://github.com/tencentyun/qcloud-iot-esp-wifi">https://github.com/tencentyun/qcloud-iot-esp-wifi</a> 、</p><p>使用git下载的命令如下：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> clone https://github.com/tencentyun/qcloud-iot-esp-wifi.git</code></pre><h4 id="下载烧写工具"><a href="#下载烧写工具" class="headerlink" title="下载烧写工具"></a>下载烧写工具</h4><p>前往乐鑫官网下载Flash下载工具：</p><p><a href="https://www.espressif.com/zh-hans/support/download/other-tools">https://www.espressif.com/zh-hans/support/download/other-tools</a></p><h4 id="固件说明"><a href="#固件说明" class="headerlink" title="固件说明"></a>固件说明</h4><p>腾讯云IoT定制的AT模组固件QCloud_IoT_AT_ESP8266，适用于所有FLASH大小为2MB或者2MB以上的 ESP8266模组。 </p><p>AT串口使用UART0，默认的Tx为GPIO1，Rx为GPIO3。但因为ESP8266的UART0 默认会在上电启动期 间输出一些打印，如果打印信息影响设备功能，可在上电期间将 U0TXD(GPIO1)、U0RXD(GPIO3) 分别 与 U0RTS (GPIO15)，U0CTS(GPIO13)进行交换，以屏蔽打印。因此提供两个版本的固件：</p><ul><li>名称包含UART_1_3的固件串口使用的Tx为GPIO1，Rx为GPIO3。 </li><li>名称包含UART_15_13的固件串口使用的Tx为GPIO15，Rx为GPIO13。 </li></ul><p>进入QCloud_IoT_AT_ESP8266_FW，本文中我们使用第一个固件</p><h4 id="烧写固件"><a href="#烧写固件" class="headerlink" title="烧写固件"></a>烧写固件</h4><h5 id="运行下载的乐鑫Flash烧写工具"><a href="#运行下载的乐鑫Flash烧写工具" class="headerlink" title="运行下载的乐鑫Flash烧写工具"></a>运行下载的乐鑫Flash烧写工具</h5><ol><li><p>选择Develop Mode</p></li><li><p>选择ESP8266下载工具</p><img src="/xyzhangblog/2020/10/01/iot/tencentostiny-jia-quan-chuan-gan-qi/tencentostiny-ti-yan/image-20201001175540012.png" class="" title="image-20201001175540012"><p>按照上图设置进行配置点击Start后等待下载完成</p></li><li><p>下载完成</p><img src="/xyzhangblog/2020/10/01/iot/tencentostiny-jia-quan-chuan-gan-qi/tencentostiny-ti-yan/image-20201001175803789.png" class="" title="image-20201001175803789"><p>完成后即可关闭工具，<strong>将串口选择端子恢复到默认状态</strong></p></li></ol><h2 id="0x04-接入腾讯云IoT"><a href="#0x04-接入腾讯云IoT" class="headerlink" title="0x04. 接入腾讯云IoT"></a>0x04. 接入腾讯云IoT</h2><h3 id="云端操作"><a href="#云端操作" class="headerlink" title="云端操作"></a>云端操作</h3><h4 id="新建项目及产品"><a href="#新建项目及产品" class="headerlink" title="新建项目及产品"></a>新建项目及产品</h4><p>项目及产品创建时保留默认选项即可</p><h4 id="数据模板"><a href="#数据模板" class="headerlink" title="数据模板"></a>数据模板</h4><p>产品界面点击“数据模板”，点击“导入json”，导入如下的json代码</p><pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span>  <span class="token property">"version"</span><span class="token operator">:</span> <span class="token string">"1.0"</span><span class="token punctuation">,</span>  <span class="token property">"profile"</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token property">"ProductId"</span><span class="token operator">:</span> <span class="token string">"BDDSF87WEA"</span><span class="token punctuation">,</span>    <span class="token property">"CategoryId"</span><span class="token operator">:</span> <span class="token string">"1"</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token property">"properties"</span><span class="token operator">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">{</span>      <span class="token property">"id"</span><span class="token operator">:</span> <span class="token string">"ch20_ppm_value"</span><span class="token punctuation">,</span>      <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"甲醛浓度值"</span><span class="token punctuation">,</span>      <span class="token property">"desc"</span><span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">,</span>      <span class="token property">"mode"</span><span class="token operator">:</span> <span class="token string">"r"</span><span class="token punctuation">,</span>      <span class="token property">"define"</span><span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"float"</span><span class="token punctuation">,</span>        <span class="token property">"min"</span><span class="token operator">:</span> <span class="token string">"0"</span><span class="token punctuation">,</span>        <span class="token property">"max"</span><span class="token operator">:</span> <span class="token string">"2"</span><span class="token punctuation">,</span>        <span class="token property">"start"</span><span class="token operator">:</span> <span class="token string">"0"</span><span class="token punctuation">,</span>        <span class="token property">"step"</span><span class="token operator">:</span> <span class="token string">"0.001"</span><span class="token punctuation">,</span>        <span class="token property">"unit"</span><span class="token operator">:</span> <span class="token string">"ppm(mg/m3)"</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      <span class="token property">"required"</span><span class="token operator">:</span> <span class="token boolean">false</span>    <span class="token punctuation">}</span>  <span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token property">"events"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token property">"actions"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre><h4 id="创建设备"><a href="#创建设备" class="headerlink" title="创建设备"></a>创建设备</h4><p>点击“设备调试”，进入后点击“新建设备”，创建成功后进入设备可以看到产品ID、设备名称、设备密钥等相关信息；</p><h3 id="传感器端操作"><a href="#传感器端操作" class="headerlink" title="传感器端操作"></a>传感器端操作</h3><p>进入 &lt; TencentOS-tiny\board\TencentOS_tiny_EVB_G0\KEIL\mqtt_iot_explorer_tc_ch20_oled&gt; 目录，打开TencentOS_tiny.uvprojx工程。</p><h4 id="修改Wifi接入信息"><a href="#修改Wifi接入信息" class="headerlink" title="修改Wifi接入信息"></a>修改Wifi接入信息</h4><p>编辑<code>mqtt_iot_explorer_tc_ch20_oled.c</code>文件，修改<code>esp8266_tencent_firmware_join_ap</code>函数中的要接入的WiFi名称和密码</p><img src="/xyzhangblog/2020/10/01/iot/tencentostiny-jia-quan-chuan-gan-qi/tencentostiny-ti-yan/image-20201001200336241.png" class="" title="image-20201001200336241"><h4 id="修改云端对接信息"><a href="#修改云端对接信息" class="headerlink" title="修改云端对接信息"></a>修改云端对接信息</h4><p>修改文件中的宏定义，对应腾讯云中的配置信息</p><img src="/xyzhangblog/2020/10/01/iot/tencentostiny-jia-quan-chuan-gan-qi/tencentostiny-ti-yan/image-20201001200710678.png" class="" title="image-20201001200710678"><p><del><strong>此处可自行发挥修改程序代码，实现更加复杂有趣的功能</strong></del></p><h4 id="编译下载"><a href="#编译下载" class="headerlink" title="编译下载"></a>编译下载</h4><p>编译完成-&gt;进入工程配置界面-&gt;选择debug选项-&gt;选择ST-Link Debugger-&gt;点击settings 该页面中的Unit选择ST-Link/V2，Port选择SW，点击确认保存配置；</p><img src="/xyzhangblog/2020/10/01/iot/tencentostiny-jia-quan-chuan-gan-qi/tencentostiny-ti-yan/@9ZW3%60FJ%60Z9RJ9%60LLK7AO8A.png" class="" title="img"><p>回到主界面点击下载；</p><h4 id="使用串口助手查看日志"><a href="#使用串口助手查看日志" class="headerlink" title="使用串口助手查看日志"></a>使用串口助手查看日志</h4><p>打开串口助手后，点击打开串口，点击开发板上的reset按钮，程序开始运行，可在主界面中查看运行日志</p><p>WiFi连接成功</p><img src="/xyzhangblog/2020/10/01/iot/tencentostiny-jia-quan-chuan-gan-qi/tencentostiny-ti-yan/U1%5B2$YTXDK@T0G@VTI01PSP.png" class="" title="img"><p>接入云平台成功</p><img src="/xyzhangblog/2020/10/01/iot/tencentostiny-jia-quan-chuan-gan-qi/tencentostiny-ti-yan/image-20201001204024547.png" class="" title="image-20201001204024547"><p>上述步骤完成后即可回到腾讯云界面查看数据上报情况</p><h2 id="0x05-成品展示"><a href="#0x05-成品展示" class="headerlink" title="0x05. 成品展示"></a>0x05. 成品展示</h2><ul><li>开发板</li></ul><img src="/xyzhangblog/2020/10/01/iot/tencentostiny-jia-quan-chuan-gan-qi/tencentostiny-ti-yan/image-20201001215542720.png" class="" title="image-20201001215542720"><ul><li>腾讯云数据展示界面</li></ul><img src="/xyzhangblog/2020/10/01/iot/tencentostiny-jia-quan-chuan-gan-qi/tencentostiny-ti-yan/image-20201001215415580.png" class="" title="image-20201001215415580"><ul><li>腾讯连连小程序数据展示界面</li></ul><img src="/xyzhangblog/2020/10/01/iot/tencentostiny-jia-quan-chuan-gan-qi/tencentostiny-ti-yan/image-20201001215931807.png" class="" title="image-20201001215931807"><ul><li>腾讯连连公众号数据报警界面</li></ul><img src="/xyzhangblog/2020/10/01/iot/tencentostiny-jia-quan-chuan-gan-qi/tencentostiny-ti-yan/image-20201001215758591.png" class="" title="image-20201001215758591"><h2 id="0x06-后记"><a href="#0x06-后记" class="headerlink" title="0x06. 后记"></a>0x06. 后记</h2><p>感谢 @supowang 大佬提供的极其详细的<a href="http://mk.oa.com/note/817">教程</a>，本文中大部分内容来自于其所写的教程步骤，另外添加了少部分自己在实践过程中的踩坑记录，后续有时间会尝试接入其他传感器完成更复杂更好玩的实践。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> IoT </tag>
            
            <tag> TencentOS-Tiny </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Block使用总结</title>
      <link href="/xyzhangblog/2020/09/24/ios-kai-fa/block-shi-yong-zong-jie/block-shi-yong-zong-jie/"/>
      <url>/xyzhangblog/2020/09/24/ios-kai-fa/block-shi-yong-zong-jie/block-shi-yong-zong-jie/</url>
      
        <content type="html"><![CDATA[<h3 id="Block应用场景"><a href="#Block应用场景" class="headerlink" title="Block应用场景"></a>Block应用场景</h3><ol><li><p>响应事件</p><blockquote><p>需求：UIViewController中使用UICollectionView构造集合视图，在集合视图中自定义Cell，每个Cell中有一个按钮，需要监听该按钮并对其做出相应</p></blockquote><p>在CellView中声明Block类型的属性，在按钮点击事件中调用该block</p><pre class=" language-objective-c"><code class="language-objective-c">//按钮点击Block@property (nonatomic, copy) void (^btnClickedBlock)(void);// 激活事件#pragma mark - 按钮点击事件- (IBAction)btnClickedAction:(UIButton *)sender {    if (self.btnClickedBlock) {        self.btnClickedBlock();    }}</code></pre><p>在ViewController中调用UICollectionView生成cell的代理方法<code>- (UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath</code>时，使用setter方法设置CellView中的block属性，其中包含按钮点击后执行的逻辑。—可以不在定义CellView时确定其执行逻辑，而是通过外部的setter方法确定</p><pre class=" language-objective-c"><code class="language-objective-c">// 设置cell 响应事件cell.btnClickedBlock = ^(UIButton *sender) {    // 执行逻辑};</code></pre></li><li><p>传递数据</p><blockquote><p>在UICollectionView中获取选中Cell的序号，根据选中的Cell执行不同逻辑</p></blockquote><pre class=" language-objective-c"><code class="language-objective-c">@property (strong, nonatomic) void (^handleDidSelectedItem)(int indexPath);- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath{    [tableView deselectRowAtIndexPath:indexPath animated:YES];    _handleDidSelectedItem ? _handleDidSelectedItem(indexPath) : NULL;}</code></pre></li></ol><h3 id="Block使用注意事项"><a href="#Block使用注意事项" class="headerlink" title="Block使用注意事项"></a>Block使用注意事项</h3><ol><li><p>局部变量与__block修饰符</p><p>block会在所在函数中捕获局部变量，但无法修改局部变量，可以修改全局变量、静态变量。</p><ul><li>不能修改局部变量：block捕获的是局部变量的const值，只是名字一样无法修改，如果想修改局部变量可以在定义时使用__block修饰。</li><li>可以修改静态变量：静态变量属于类，可以在block中调用</li></ul></li><li><p>循环引用问题</p><p>Self持有Block对象, 同时在Block内部又调用了Self, 导致了Self持有Block, Block又持有Self，那就会引起循环引用</p><ul><li><p>TestCycleRetain.m</p><pre class=" language-objective-c"><code class="language-objective-c">- (void) dealloc {    NSLog(@"no cycle retain");} - (id) init {    self = [super init];    if (self) {        #if TestCycleRetainCase1        //会循环引用        self.myblock = ^{            [self doSomething];        };        #endif NSLog(@"myblock is %@", self.myblock);    }    return self;} </code></pre></li></ul><p>循环引用的避免：声明一个self的弱指针，在block中引用该弱指针</p><pre class=" language-objective-c"><code class="language-objective-c">                #elif TestCycleRetainCase3        //不会循环引用        __weak TestCycleRetain * weakSelf = self;        self.myblock = ^{            [weakSelf doSomething];        };</code></pre><p>上述使用block中存在一个隐患，不知道self什么时候会被释放，为了保证在block中不会被释放，需要配合strong来使用</p><pre class=" language-objective-c"><code class="language-objective-c">__weak __typeof(self) weakSelf = self; self.testBlock =  ^{    __strong __typeof(weakSelf) strongSelf = weakSelf;       [strongSelf test]; });</code></pre><blockquote><p>From: Raven</p><p>以上操作带来一个疑问:<strong>通过弱引用接触循环引用的Self, 如果在Block内部再强引用, 岂不是又循环引用了吗?到底是如何延长Self的生命周期的?</strong></p><p><strong>解答</strong>:</p><p>block被赋值到<code>self</code>的成员变量时, arc下系统会将该block从栈区拷贝到堆区, 此时block会捕获它所用到的变量使用<code>__weak</code>可以保证block和<code>self</code>之间不会发生循环引用, 而在Block的代码块内声明<code>_ _strong</code>指针, 将会对self产生一个强引用延迟self的释放, 但和直接使用<code>self</code>所不同的是, <strong>在Block内声明的指针会在Block的作用域外销毁</strong>, 因此这个循环引用只会持续到block执行完毕为止, 当block执行完毕, strongSelf被销毁, <code>self</code>不再被Block所持有, 就可以顺利释放了.</p></blockquote></li></ol><ol start="3"><li><p>并不是所有Block里面的self都需要weak</p><ul><li><p>调用系统方法：</p><pre class=" language-objective-c"><code class="language-objective-c">[UIView animateWithDuration:0.5 animations:^{        NSLog(@"%@", self);}];</code></pre><p>这个block本身存在于静态方法中，虽然block对self强引用，但self不持有该静态方法，所以完全可以在block内部使用self</p></li></ul></li></ol><h3 id="block与内存管理"><a href="#block与内存管理" class="headerlink" title="block与内存管理"></a>block与内存管理</h3><p>根据Block在内存中的位置分为三种类型：</p><ul><li>NSGlobalBlock：全局区block，设置在程序的数据区域中</li><li>NSStackBlock：栈区，超出变量作用域则栈上的Block和__block变量都被销毁</li><li>NSMallocBlock：堆区，在变量作用域结束时不受影响</li></ul><ol><li><p>位于全局区：GlobalBlock</p><p>生成在全局区的block的情况：</p><ul><li><p>直接将block定义为全局变量</p><pre class=" language-objective-c"><code class="language-objective-c">void(^block)(void) = ^ { NSLog(@"Global Block");};int main() {}</code></pre></li></ul></li><li><p>位于栈内存：StackBlock –最常见的block</p><pre class=" language-objective-c"><code class="language-objective-c">NSInteger i = 10; block = ^{      NSLog(@"%ld", i); };block;</code></pre></li><li><p>位于堆内存：MallocBlock</p><p>堆中block无法直接创建，需要执行copy后才能放入堆中</p></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Block </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
